#!/bin/bash

# global variables
pkg=$(basename $0)
version="0.8"
pkg_path=$(cd $(dirname $0); pwd -P)
gcreds_log="$pkg_path/logs/gcreds.log"
host=$(hostname)
system=$(uname)
#
TIMEOUT=900         # temp creds expiration, 1 hour

# Formatting
blue=$(tput setaf 4)
cyan=$(tput setaf 6)
green=$(tput setaf 2)
purple=$(tput setaf 5)
red=$(tput setaf 1)
white=$(tput setaf 7)
yellow=$(tput setaf 3)
gray=$(tput setaf 008)
lgray='\033[0;37m'      # light gray
dgray='\033[1;30m'       # dark gray
reset=$(tput sgr0)
#   
BOLD=`tput bold`              
UNBOLD=`tput sgr0` 

# error codes
E_DEPENDENCY=1                # exit code if missing required dependency
E_NOLOG=2                     # exit code if failure to create log dir, log file
E_BADSHELL=3                  # exit code if incorrect shell detected
E_AUTHFAIL=5                  # exit code if authentication failure
E_USER_CANCEL=7               # exit code if user cancel
E_BADARG=8                    # exit code if bad input parameter        
E_MISC=11                     # exit code if miscellaneous (unspecified) error

#<-- function declaration -->

function indent02() { sed 's/^/  /'; }

function indent10() { sed 's/^/          /'; }

function gcreds-logger(){
    local msg="$1"
    if [[ ! $gcreds_log ]]; then
        echo "$pkg: failure to call gcreds-logger, $gcreds_log location undefined"
        exit $E_NOLOG
    fi
    echo "$(date +'%b %d %T') $host $pkg: $msg" >> "$gcreds_log"
}

function gcreds-message(){
    local msg="$1"
    gcreds-logger "INFO: $msg"
    [[ $quiet ]] && return
    shift
    pref="----"
    if [[ $1 ]]; then
        pref="${1:0:4}"
        shift
    fi
    echo -e "\n${yellow}[ $cyan$pref$yellow ]$reset  $msg\n"
}

function gcreds-error(){
    local msg="$1"
    gcreds-logger "ERROR: $msg"
    echo -e "\n${yellow}[ ${red}ERRR$yellow ]$reset  $msg\n"
}

function gcreds-error-exit(){
    local msg="$1"
    local status="$2"
    gcreds-error "$msg"
    exit $status
}

function gcreds-depcheck(){
    ## test default shell ##
    if [ ! -n "$BASH" ]; then
        # shell other than bash 
        gcreds-error-exit "Default shell appears to be something other than bash. Please rerun with bash. Aborting (code $E_BADSHELL)" $E_BADSHELL
    fi 

    ## create log dir for gcreds ##
    if [[ ! -d $pkg_path/logs ]]; then
        if ! mkdir -p "$pkg_path/logs"; then
            gcreds-error-exit "$pkg: failed to make log directory: $pkg_path/logs" $E_NOLOG
        fi
    fi

    ## set fs pointer to writeable temp location ##
    if [ "$(df /run | awk '{print $1, $6}' | grep tmpfs 2>/dev/null)" ]; then
            # in-memory
            TMPDIR="/dev/shm"
            cd $TMPDIR     
    else
            TMPDIR="/tmp"
            cd $TMPDIR 
    fi    

    ## check for required cli tools ##
    for prog in aws jq; do
        if ! type "$prog" > /dev/null 2>&1; then
            gcreds-error-exit "$prog is required and not found in the PATH. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
    done

    ## check if awscli tools are configured ##
    if [[ ! -f $HOME/.aws/config ]]; then
        gcreds-error-exit "awscli not configured, run 'aws configure'. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
    fi

    ## check for jq, use system installed version if found, otherwise use bundled ##
    if which jq > /dev/null; then
        jq=$(which jq)
    else
        jq="assets/jq/$system/jq"
        if [[ ! -f $jq ]]; then
            gcreds-error-exit "no viable json parser binary (jq) found, Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
    fi

    ## check temp credential lifetime > required min
    if [[ $TIMEOUT -lt 900 ]]; then
        gcreds-error-exit "Requested temporary credential lifetime must be 15 minutes or more. Exiting (code $E_AUTHFAIL)" $E_AUTHFAIL
    fi
    #
    # <-- end function gcreds-depcheck -->
    #
}

function gcreds-authentication(){
    # validate authenthentication to aws apis before writing to awscli config
    if [[ ! $1 ]] || [[ ! $2 ]] || [[ ! $3 ]]; then
        # authenication failed, most likely invalid mfa token
        gcreds-clean .aua.creds.json
        gcreds-error-exit "Authentication Failure: MFA code incorrect. (code $E_AUTHFAIL)" $E_AUTHFAIL
    fi
    #
    #<-- end function gcreds-authentication -->
    #
}

function gcreds-backup(){
    # backup existing awscli config
    if [[ ! -e ~/.aws/credentials.orig ]]; then
        # no config bkup, create 
        cp ~/.aws/credentials ~/.aws/credentials.orig
    fi
    #
    #<-- end functions gcreds-backup -->
    #
}

function gcreds-clean(){
    # delete all files given as parameters
    rm $@
    #
    #<-- end function gcreds-clean -->
    #
}

function gcreds-revert-creds(){
    # deletes temp credentials from local awscli config
    echo -e "\n${red}${BOLD}WARNING:${UNBOLD}${reset}\n" | indent10
    echo -e "All temp credentials from your local config will be discarded." | indent02
    echo -e "Your local awscli config will be returned to previous (clean) state.\n" | indent02
    read -p "  ${yellow}Are you sure you want to proceed?${reset} [n]:  " CHOICE 

    if [[ -z "$CHOICE" ]] || [[ "$CHOICE" == "n" ]]; then
        gcreds-message "Temporary credentials remain in your config. Nothing done." INFO
    elif [[ "$CHOICE" == "y" ]] || [[ "$CHOICE" == "yes" ]]; then
        # ensure backup exists
        if [[ -e ~/.aws/credentials.orig ]]; then
            mv ~/.aws/credentials.orig ~/.aws/credentials
            gcreds-message "Your local config has been cleaned." INFO
        else
            # no backup exists, clean 
            gcreds-message "Nothing done. Your config appears to be clean already." INFO
        fi
    else
        gcreds-message "Nothing done." INFO
    fi
    #
    # <-- end function gcreds-revert-creds -->
    #
}

function gcreds-parse-parameters(){
    ## help requested ##
    if [[ ! $@ ]]; then
        # display help
        gcreds-help
    else   
        case $1 in
            -h | --help | -help)
                # display help
                gcreds-help
                ;;
            -r | revert | rever | Revert)
                gcreds-revert-creds
                exit 0
                ;;
        esac
    fi
    ## check number ##
    if [ $# -ne 3 ]; then
        gcreds-error "3 parameters are required, only $# provided (code $E_BADARG)." $E_BADARG
        gcreds-help
    fi
    
    # set assignments
    ACCTFILE=$pkg_path/$1       # profiles to gen temp creds, one per line
    MFA_PROFILE=$2              # iam user profile used to assume roles
    MFA_CODE=$3                 # otp code

    ## verify valid mfa_profile ##
    MFA_ARN=$(aws configure get $2.mfa_serial)
    if [[ $MFA_ARN == "" ]]; then
        gcreds-error "Invalid MFA profile name provided. (code $E_BADARG)." $E_BADARG
        gcreds-help
    fi
    #
    # <-- end function gcreds-parse-parameters -->
    #
}

function gcreds-help(){
    cat <<EOM
 
 Help Contents
 -------------

    To generate temporary credentials:

    ${white}${BOLD}Usage${UNBOLD}${reset} : $pkg [OPTION] [profiles.list] [MFA_PROFILENAME] [MFA_TOKEN]

    ${white}${BOLD}Options${UNBOLD}${reset} : (not currently implemented)
        -t, --timeout=N :  temp credential expiration in N seconds (900 sec minimum)
        -s, --silent    :  when given, suppresses all stout messages

    ${white}${BOLD}profiles.list${reset}${UNBOLD} (required)
        list of profile names from your local awscli configuration, one per line
        corresponding to IAM role profiles for which you wish to generate
        temporary credentials. Profiles.list must be in gcreds root directory

    ${white}${BOLD}MFA_PROFILENAME${reset}${UNBOLD} (required)
        profile name in your local awscli configuration that contains the
        arn of your mfa_serial used when assuming roles 

    ${white}${BOLD}MFA_TOKEN${reset}${UNBOLD} (required)
        6 digit numerical code from either a hardware or virtual mfa device
        mfa code must correspond to the MFA_PROFILENAME given        

    ---------------------------------------------------------------------------

    To remove temporary credentials:

    ${white}${BOLD}Usage${UNBOLD}${reset} : $pkg [OPTIONS]

        -r, revert    Cleans temporary credentials from your local
                      awscli configuration, returning your config to
                      a pre-gcreds state.

EOM
    exit 0
    #
    #<-- end function gcreds-help -->
    #
}

function gcreds-check-creds(){
    # verify existence of previous temp credentials
    if [[ $(grep "gcreds" ~/.aws/credentials) ]]; then
        gcreds-message "You appear to have active temp credentials already in your local config." WARN
        # clear active creds by restoring from backup
        gcreds-revert-creds
        # restor backup of awscli
        gcreds-backup
    fi
    #
    #<-- end function gcreds-check-creds -->
    #
}

#<-- start MAIN -->

# check deps
gcreds-depcheck

# verify backup of existing awscli config
gcreds-backup

# parse inputs
gcreds-parse-parameters $@

# check for active temp credentials before generating new creds
gcreds-check-creds

# generate temp creds for AUA1
aws sts get-session-token \
    --duration-seconds "$TIMEOUT" \
    --serial-number "$MFA_ARN" \
    --token-code "$MFA_CODE" \
    --profile $MFA_PROFILE 2>/dev/null > .aua.creds.json

# create temp profile
AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId .aua.creds.json)
AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey .aua.creds.json)
AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken .aua.creds.json)

# validate authentication
gcreds-authentication $AWS_ACCESS_KEY $AWS_SECRET_KEY $AWS_SESSION_TOKEN

echo " " > ./.new.profile
echo "[gcreds-$MFA_PROFILE]" >> ./.new.profile
echo "aws_access_key_id = $AWS_ACCESS_KEY" >> ./.new.profile
echo "aws_secret_access_key = $AWS_SECRET_KEY" >> ./.new.profile
echo "aws_security_token = $AWS_SESSION_TOKEN" >> ./.new.profile

cat ./.new.profile >> ~/.aws/credentials

# create temp credentials for each profile in ACCTFILE
for profile in $(cat $ACCTFILE); do
    ### Need to validate that profile ###
    ### exists in local config HERE ###
    # use local config to pull role_arn
    role_arn=$(aws configure get $profile.role_arn)
    echo -e "\nGenerating temp credentials for profile ${white}${BOLD}$profile${reset}${UNBOLD}"
    echo -e "Assuming role: ${lgray}$role_arn${reset}\n"

    # call assume role to gen temp creds
    aws sts assume-role \
        --role-arn "$role_arn" \
        --role-session-name "gcreds-$profile" \
        --profile "gcreds-$MFA_PROFILE" > .creds.json

    # create temp profile
    AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId .creds.json)
    AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey .creds.json)
    AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken .creds.json)

    echo " " > ./.new.profile
    echo "[gcreds-$profile]" >> ./.new.profile
    echo "aws_access_key_id = $AWS_ACCESS_KEY" >> ./.new.profile
    echo "aws_secret_access_key = $AWS_SECRET_KEY" >> ./.new.profile
    echo "aws_security_token = $AWS_SESSION_TOKEN" >> ./.new.profile

    # add to local config
    cat ./.new.profile >> ~/.aws/credentials
done

# clean up temp files
gcreds-clean .aua.creds.json .creds.json .new.profile

#<-- end -->

exit 0