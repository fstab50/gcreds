#!/bin/bash

# global variables
VERSION='2.1'
pkg=$(basename $0)
pkg_path=$(cd $(dirname $0); pwd -P)
pwd_path=$(pwd)
config_path="$HOME/.$pkg"
gcreds_conf="gcreds.cfg"
gcreds_log="/var/log/gcreds.log"
lib_path="/usr/local/lib/$pkg"
host=$(hostname)
system=$(uname)
MONITOR=False
DBUGMODE=""                 # change this value to "True" to turn on verbose \
                            # log output to aid debugging

# Amazon Sercurity Token Service (STS) globals
STS_MIN=60                  # minutes, STS min credential lifetime
STS_MAX=720                 # minutes, credential lifetime max limit (12 hours)
TOKEN_DEFAULT=60            # minutes, default STS session token lifetime
CREDENTIAL_DEFAULT=60       # minutes, default lifetime of temp credentials generated

# error codes
E_DEPENDENCY=1              # exit code if missing required dependency
E_DIR=2                     # exit code if failure to create log dir, log file
E_BADSHELL=3                # exit code if incorrect shell detected
E_AUTHFAIL=5                # exit code if authentication failure
E_BADPROFILE=6              # exit code if profile name/ role not found in local config
E_USER_CANCEL=7             # exit code if user cancel
E_BADARG=8                  # exit code if bad input parameter
E_EXPIRED_CREDS=9           # exit code if temporary credentials no longer valid
E_MISC=11                   # exit code if miscellaneous (unspecified) error

# Formatting
blue=$(tput setaf 4)
cyan=$(tput setaf 6)
green=$(tput setaf 2)
purple=$(tput setaf 5)
red=$(tput setaf 1)
white=$(tput setaf 7)
yellow=$(tput setaf 3)
orange='\033[38;5;95;38;5;214m'
gray=$(tput setaf 008)
lgray='\033[38;5;95;38;5;245m'    # light gray
dgray='\033[38;5;95;38;5;8m'      # dark gray
reset=$(tput sgr0)
#
BOLD=`tput bold`
UNBOLD=`tput sgr0`

# initialize default color scheme
accent=$(tput setaf 008)
ansi=$(echo -e ${orange})   # use for ansi escape color codes


# source dependencies
source $lib_path/std_functions.sh


#
# function declaration start --------------(do not modify this line)-----------
#

# indent
indent02() { sed 's/^/  /'; }
indent04() { sed 's/^/    /'; }
indent10() { sed 's/^/          /'; }

function gcreds_help(){
    cat <<EOM

                          ${accent}${BOLD}$pkg${UNBOLD}${reset} help contents

 ${accent}${BOLD}DESCRIPTION${UNBOLD}${reset}:

        $pkg generates temporary credentials used to assume roles across
        many accounts.  It's commonly used for progammatic use cases where
        avoiding  multi-factor auth prompt in a cli environment is desired

 ${accent}${BOLD}USAGE${UNBOLD}${reset}:

               ${BOLD}$pkg  -a ${UNBOLD}<value>  ${BOLD}--profile${UNBOLD} <value>  ${BOLD}-c${UNBOLD} <value>

 ${accent}${BOLD}SYNOPSIS${UNBOLD}${reset}:
                            -a, --accounts
                            -p, --profile
                            -c, --mfa-code
                           [-A, --auto    ]
                           [-C, --config  ]
                           [-s, --show    ]
                           [-u, --awscli  ]
                           [-h, --help    ]
 ${accent}${BOLD}OPTIONS${UNBOLD}${reset}:

      ${accent}${BOLD}-a, --accounts${reset} <${accent}value${reset}>:  Text file listing of profile names in your
          local awscli configuration,  one per line.  Names correspond to
          IAM roles for which you wish to generate temporary credentials.

      ${accent}${BOLD}-u, --awscli${reset}: Configure runtime options via menu.

      ${accent}${BOLD}-p, --profile${reset} ${reset}<${accent}value${reset}>:  Profile name of the IAM user from your local
          awscli config you will use to generate temporary iam credentials.

      ${accent}${BOLD}-c, --mfa-code${reset} ${reset}<${accent}value${reset}>:  6 digit otp code from either a hardware or
          virtual multi-factor authentication (mfa) device.

      ${accent}${BOLD}-A, --auto ${reset}<${accent}value${reset}>: Auto refresh temporary credentials for specified
          number of hours. If omitted, temporary credentials are generated
          only once and expire after 60 min (default timeout).

      ${accent}${BOLD}-C, --config${reset}: Configure may be invoked at any time to set (or reset)
          $pkg runtime options.  Config options override gcreds defaults
          when set.

      ${accent}${BOLD}-s, --show ${reset}: Display credential expiration stats.

      ${accent}${BOLD}-h, --help ${reset}: Display this help menu.
      ______________________________________________________________________

        New profiles added to your awscli config prefixed with '${BOLD}gcreds-${UNBOLD}'
      ______________________________________________________________________

        To remove temporary credentials:

        ${accent}${BOLD}USAGE${UNBOLD}${reset} : $pkg -r

          ${accent}${BOLD}-r, --remove${reset}  :  Clears temporary credentials from your local
                           awscli configuration, returning your config to
                           a pre-gcreds state.

EOM
    exit 0
    #
    #<-- end function gcreds_help -->
}

function array2json(){
    ## converts associative array to json file output ##
    local -n array_dict=$1      # local assoc array must use -n opt
    local output_file=$2        # location
    local ct                    # counter
    local max_keys              # num keys in array
    #
    echo -e "{" > $output_file
    ct=1
    max_keys=${#array_dict[@]}
    for key in ${!array_dict[@]}; do
        if [ $ct == $max_keys ]; then
            # last key, no comma
            echo "\"${key}\": \"${array_dict[${key}]}\"" | indent04 >> $output_file
        else
            echo "\"${key}\": \"${array_dict[${key}]}\"," | indent04 >> $output_file
        fi
        ct=$(( $ct + 1 ))
    done
    echo -e "}" >> $output_file
    #
    # <-- end function array2json -->
}

function std_logger(){
    local msg="$1"
    if [[ ! $gcreds_log ]]; then
        echo "$pkg: failure to call std_logger, $gcreds_log location undefined"
        exit $E_DIR
    fi
    echo "$(date +'%b %d %T') $host $pkg: $msg" >> "$gcreds_log"
}

function std_message(){
    local msg="$1"
    local format="$3"
    #
    std_logger "[INFO]: $msg"
    [[ $quiet ]] && return
    shift
    pref="----"
    if [[ $1 ]]; then
        pref="${1:0:5}"
        shift
    fi
    if [ $format ]; then
        echo -e "${yellow}[ $cyan$pref$yellow ]$reset  $msg" | indent04
    else
        echo -e "\n${yellow}[ $cyan$pref$yellow ]$reset  $msg\n" | indent04
    fi
}

function std_error(){
    local msg="$1"
    std_logger "[ERROR]: $msg"
    echo -e "\n${yellow}[ ${red}ERROR${yellow} ]$reset  $msg\n" | indent04
}

function std_warn(){
    local msg="$1"
    std_logger "[WARN]: $msg"
    if [ "$3" ]; then
        # there is a second line of the msg, to be printed by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg" | indent04
    else
        # msg is only 1 line sent by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg\n" | indent04
    fi
}

function std_error_exit(){
    local msg="$1"
    local status="$2"
    std_error "$msg"
    exit $status
}

function gcreds_env_info(){
    local msg_header=$1
    local dep=$2
    local version_info
    local awscli_ver
    local boto_ver
    local python_ver
    #
    version_info=$(aws --version 2>&1)
    awscli_ver=$(echo $version_info | awk '{print $1}')
    boto_ver=$(echo $version_info | awk '{print $4}')
    python_ver=$(echo $version_info | awk '{print $2}')
    #
    if [[ $dep == "aws" ]]; then
        std_logger "[$msg_header]: awscli version detected: $awscli_ver"
        std_logger "[$msg_header]: Python runtime detected: $python_ver"
        std_logger "[$msg_header]: Kernel detected: $(echo $version_info | awk '{print $3}')"
        std_logger "[$msg_header]: boto library detected: $boto_ver"

    elif [[ $dep == "awscli" ]]; then
        std_message "awscli version detected: ${accent}${BOLD}$awscli_ver${UNBOLD}${reset}" $msg_header "pprint" | indent04
        std_message "boto library detected: ${accent}${BOLD}$boto_ver${UNBOLD}${reset}" $msg_header "pprint" | indent04
        std_message "Python runtime detected: ${accent}${BOLD}$python_ver${UNBOLD}${reset}" $msg_header "pprint" | indent04

    elif [[ $dep == "jq" ]]; then
        version_info=$(jq --version 2>&1)
        std_logger "[$msg_header]: json parser detected: $(echo $version_info)"
    else
        std_logger "[$msg_header]: detected: $($prog --version | head -1)"
    fi
    #
    #<-- end function gcreds_env_info -->
}

function gcreds_depcheck(){
    ## test default shell ##
    if [ ! -n "$BASH" ]; then
        # shell other than bash
        std_error_exit "Default shell appears to be something other than bash. Please rerun with bash. Aborting (code $E_BADSHELL)" $E_BADSHELL
    fi
    ## create log dir for gcreds ##
    if [[ ! -d $pkg_path/logs ]]; then
        if ! mkdir -p "$pkg_path/logs"; then
            std_error_exit "$pkg: failed to make log directory: $pkg_path/logs" $E_DIR
        fi
    fi
    ## create gcreds config dir ##
    if [[ ! -d $config_path ]]; then
        std_warn "config_path not found, creating config dir $config_path"
        if ! mkdir -p $config_path; then
            std_error_exit "$pkg: failed to create local config file directory: ~/.$pkg" $E_DIR
        fi
    fi
    ## check for required cli tools ##
    for prog in aws jq date hostname awk grep cat python3; do
        if ! type "$prog" > /dev/null 2>&1; then
            std_error_exit "$prog is required and not found in the PATH. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
        if [ $DBUGMODE ]; then
            gcreds_env_info "DBUG" $prog
        fi
    done
    ## check if awscli tools are configured ##
    if [[ ! -f $HOME/.aws/config ]]; then
        std_error_exit "awscli not configured, run 'aws configure'. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
    fi
    ## check for jq, use system installed version if found, otherwise use bundled ##
    if which jq > /dev/null; then
        jq=$(which jq)
    else
        jq="assets/jq/$system/jq"
        if [[ ! -f $jq ]]; then
            std_error_exit "no viable json parser binary (jq) found, Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
    fi
    ## set temp to writeable location in physical memory ##
    df=$(which df)
    if [ "$($df /run 2>/dev/null | awk '{print $1, $6}' | grep tmpfs 2>/dev/null)" ]; then
            # in-memory
            TMPDIR="/dev/shm"
    else
            TMPDIR="/tmp"
    fi
    ## set parameters based on configuration options ##
    gcreds_source_config
    #
    # <-- end function gcreds_depcheck -->
}

function gcreds_authentication(){
    # validate authenthentication to aws apis before writing to awscli config
    if [ ! $1 ] || [ ! $2 ] || [ ! $3 ]; then
        # authenication failed, most likely invalid mfa token
        gcreds_clean .aua.creds.json
        std_error_exit "Authentication Failure: MFA code incorrect. (code $E_AUTHFAIL)" $E_AUTHFAIL
    fi
    #
    #<-- end function gcreds_authentication -->
}

function gcreds_backup(){
    # backup existing awscli config
    if [[ ! -e ~/.aws/credentials.orig ]]; then
        # no config bkup, create
        cp ~/.aws/credentials ~/.aws/credentials.orig
    fi
    #
    #<-- end functions gcreds_backup -->
}

function gcreds_clean(){
    # delete all files given as parameters
    if [[ $1 = .* ]]; then
        # temp files
        cd $TMPDIR
        rm $@
        cd $pwd_path
    else
        rm $@
    fi
    #
    #<-- end function gcreds_clean -->
}

function gcreds_configure(){
    ## set configuration options ##
    local ct                        # counter
    local valid                     # loop break
    local CHOICE                    # user entry var
    local COLOR                     # user entry var
    local maxct                     # array size counter
    local clear_bin=$(which clear)  # clear screen bin file
    local version                   # installed gcreds' version in conf file
    local mfa_profile               # value, default_profile key in conf file
    local color_scheme              # value, default_color key in conf file
    local tmp_profile               # pre-existing default_profile value in conf file
    local tmp_scheme                # pre-existing default_color value in conf file
    #
    declare -A config_dict          # key, value dictionary
    declare colors                  # color scheme array
    #
    $clear_bin      # clear screen
    version=$VERSION

    # check if config already exists, if so parse parameters
    if [ -e $config_path/$gcreds_conf ]; then
        mfa_profile=$(cat $config_path/$gcreds_conf | jq -r .default_profile)
        color_scheme=$(cat $config_path/$gcreds_conf | jq -r .default_color)
    else
        mfa_profile='atos-aua1'
        color_scheme='LTDB'
    fi

    echo -e "\n"
    std_message "Configure Mode Start: Set $pkg configuration options" INFO
    # set default profile (default  [atos-aua1])
    echo -e "\nEnter the iam username you will generally use to generate temporary" | indent02
    echo -e "credentials. This user is used to assume roles using temporary credentials" | indent02
    echo -e "provided by $pkg." | indent02
    echo -e "\nA new iam user may be used at any time by including the -p / --profile" | indent02
    echo -e "option as a $pkg command line parameter.\n" | indent02
    read -p "  ${yellow}IAM user [$mfa_profile]:${reset} " CHOICE
    if [ -z $CHOICE ]; then
        CHOICE=$mfa_profile
    fi
    echo -e "\n"
    std_message "entering [$CHOICE] in your local $pkg configuration" INFO
    # add config dictionary key, value
    config_dict["default_profile"]=$CHOICE

    # set default color scheme (display choices)
    colors=(
        "LTDB: Light text on dark background (default)"
        "DTLB: Dark text on light background"
        "BLUE: Blue Accent Theme"
        "ORNG: Orange Accent Theme"
        "GREEN: Green Accent Theme"
        )
    maxct=${#colors[@]}
    echo -e "\nChoose a default color scheme based on your cli environemnt. Choices:\n" | indent02
    ct=0
    valid=0     # loop break
    while [ $ct -lt ${#colors[@]} ]; do
        echo "[$ct]: ${colors[$ct]}" | indent04
        ct=$(( $ct + 1))
    done
    while [ $valid -eq 0 ]; do
        # validate user input
        echo -e "\n"
        read -p "  ${yellow}Select number of color scheme [$color_scheme]:${reset} " CHOICE

        case $color_scheme in
            LTDB) color_choice=0 ;;
            DTLB) color_choice=1 ;;
            BLUE) color_choice=2 ;;
            ORNG) color_choice=3 ;;
            GREEN) color_choice=4 ;;
        esac

        if [[ -n ${CHOICE//[0-$(( $maxct-1 ))]/} ]]; then
            # invalid user entry
            echo -e "\nYou must enter an integer number between 0 and $(( $maxct-1 ))."
        else
            # valid user entry, exit loop
            valid=1
        fi
    done
    if [ -z $CHOICE ]; then
        # add config dictionary key, value for 0 element
        COLOR=$(echo ${colors[$color_choice]} | awk -F ':' '{print $1}')
    else
        # add config dictionary key, value
        COLOR=$(echo ${colors[$CHOICE]} | awk -F ':' '{print $1}')
    fi

    # add config dictionary key, value
    config_dict["default_color"]=$COLOR
    echo -e "\n"
    std_message "Entering color scheme [${accent}$COLOR${reset}] in your local configuration" INFO "console"

    # installed version
    config_dict["version"]=$version
    std_message "Installed version [$pkg ${accent}v$version${reset}] recorded to your local configuration" INFO

    # write out config file
    array2json config_dict $config_path/$gcreds_conf

    # log
    std_message "Configuration setup for $pkg complete" INFO "console"
    echo -e '\n'
    exit 0
    #
    # <-- end function gcreds_configure -->
}

function gcreds_profile_exists(){
    ## validate if profile exists in local awscli config ##
    #
    if [[ $1 == "" ]] && [[ $1 == $MFA_ARN ]]; then
        std_error_exit "Invalid MFA profile name provided ($MFA_PROFILE) Exiting code $E_BADARG." $E_BADARG

    elif [ ! $1 ]; then
        std_warn "Profile name ($profile) not in your local config. (code $E_BADPROFILE)." $E_BADPROFILE
        return 1
    fi
    return 0
    #
    #<-- end function gcreds_profile_exists -->
}

function gcreds_parse_parameters(){
    ## help requested ##
    if [[ ! $@ ]]; then
        # display help
        gcreds_help
    else
        while [ $# -gt 0 ]; do
            case $1 in
                -h | --help | -help)
                    # display help
                    gcreds_help
                    ;;
                -C | --config)
                    # set configuration options
                    gcreds_configure
                    exit 0
                    ;;
                -r | --remove)
                    rm=1    # flag indicating direct call to clear config
                    if ! gcreds_preexisting_creds $rm; then
                        std_message "You do not have temporary credentials in your config. Nothing to do." INFO
                    fi
                    exit 0
                    ;;
                -a | --accounts | *.accounts | *.accts)
                    # list of accts to gen temp creds, one per line
                    # -f, --file, *.accounts, *.accts for backward compatibility
                    if [ $1 == "-a" ] || [ $1 == "--accounts" ]; then
                        ACCTFILE=$2
                        shift 2
                    fi
                    ;;
                -p | --profile)
                    # iam user profile used to assume roles
                    if [ $2 ]; then
                        MFA_PROFILE=$2
                        shift 2
                    else
                        std_error_exit "You must provide an IAM profile name. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                --mfa-code | --mfacode | --mfa | --code | -c)
                    # otp code from virtual or hw mfa device. verify 6 digit int
                    if [[ $2 =~ ^[0-9]{6}$ ]]; then
                        MFA_CODE=$2
                        shift 2
                    else
                        std_error_exit "You must enter a valid 6 digit mfa code. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                -s | --show)
                    # display info on current credentials, if exist
                    gcreds_show_creds
                    shift 1
                    exit 0
                    ;;
                -A | --auto)     # optional
                    if [ $2 ]; then
                        # $2 given in hours
                        TOKEN_LIFE=$2
                        MONITOR=True    # set monitoring bit
                        shift 2
                    else
                        std_error_exit "You must provide a timeout value. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                -u | --awscli)
                    # display info on current credentials, if exist
                    update_awscli
                    shift 1
                    exit 0
                    ;;
                *)
                    # invalid argument
                    std_error_exit "Unrecognized argument [ $1 ] given. Exiting (code $E_BADARG)" $E_BADARG
            esac
        done
    fi
    ## check that min required parameters have been supplied ##
    if [ ! $ACCTFILE ]; then
        std_error "You must provide an account list, exiting (code $E_BADARG)." $E_BADARG
        gcreds_help
    fi
    if [ ! $MFA_PROFILE ]; then
        std_error "You must enter an IAM user used to assume roles. Exiting (code $E_BADARG)" $E_BADARG
        gcreds_help
    fi
    if [ ! $MFA_CODE ]; then
        std_error "You must enter a valid 6 digit mfa code. Exiting (code $E_BADARG)" $E_BADARG
        gcreds_help
    fi

    # set remaining assignments
    MFA_ARN=$(aws configure get $MFA_PROFILE.mfa_serial)
    # verify valid mfa_profile
    gcreds_profile_exists $MFA_ARN

    # set session token
    if [[ ! $TOKEN_LIFE ]]; then
        TOKEN_LIFE=$TOKEN_DEFAULT  # default token expiration (minutes)
    else
        # validate session token lifetime
        STS_MIN=$(( $STS_MIN/60 ))
        STS_MAX=$(( $STS_MAX/60 ))
        gcreds_validate_parameter $TOKEN_LIFE int "Temp credential lifetime" $STS_MIN $STS_MAX "hours"
        TOKEN_LIFE=$(( $TOKEN_LIFE*60 ))
    fi
    #
    # <-- end function gcreds_parse_parameters -->
}

function gcreds_preexisting_creds(){
    # verify existence of previous temp credentials
    if [[ $(grep "gcreds" ~/.aws/credentials) ]]; then
        if [ ! $1 ]; then
            # not a direct call via revert parameter
            std_message "Temporary credentials found in your local awscli config." INFO
            # clear active creds by restoring from backup, silent mode
            gcreds_remove_creds -s
        else
            # clear active creds by restoring from backup, interactive mode
            gcreds_remove_creds
        fi
        # restor backup of awscli
        gcreds_backup
    else
        # no preexisting credentials in local config
        return 1
    fi
    #
    #<-- end function gcreds_preexisting_creds -->
}

function gcreds_remove_creds(){
    ## deletes temp credentials from local awscli config ##
    #
    local silent=$1
    #
    # log out start
    std_logger "[INFO]: Attempting to remove temp credentials from local config"
    # header
    cat<<EOM

                        --${accent}${BOLD} CLEARING LOCAL CONFIG ${UNBOLD}${reset}--

    All temporary credentials generated by $pkg in your local config
    will be discarded. Your local awscli config will be returned to
    its previous (clean) state.

EOM
    if [ $silent ]; then
        # clean config, no user input
        CHOICE="y"
    else
        read -p "  ${yellow}  Purge existing temporary credentials?${reset} [y]:  " CHOICE
    fi
    if [[ -z "$CHOICE" ]] || [[ "$CHOICE" == "y" ]] || [[ "$CHOICE" == "yes" ]]; then
        # restore clean config from backup
        if [[ -e ~/.aws/credentials.orig ]]; then
            mv ~/.aws/credentials.orig ~/.aws/credentials
            std_message "Your local config has been cleaned." INFO
            # clear existing credential expiration values
            gcreds_update_expiration 0
            # replace backup with new copy
            gcreds_backup
        else
            # no backup exists, clean
            std_message "Nothing done. Your config appears to be clean already." INFO
        fi
    else
        std_message "Temporary credentials remain in your config. Nothing done." INFO
    fi
    #
    # <-- end function gcreds_remove_creds -->
}


function display_credential_profilenames(){
    ##
    ##  displays temporary credentials profilenames
    ##  from local awscli configuration if found
    ##
    local awscli_dir="$1"
    local ct='1'

    for row in $(grep gcreds "$awscli_dir" | cut -c 2-80 | rev | cut -c 2-80 | rev); do
        echo -e "- ${cyan}$row${reset}" | indent10
        ct=$(( $ct + 1 ))
    done
}


function gcreds_show_creds(){
    ## display credentials in local config ##
    local session_life="$1"     # time remaining in session, minutes
    local credential_life       # seconds until temporary credential expire
    local hrs_left              # duration before expiration, hours
    local min_left              # duration before expiration, min
    local expire                # expiration timestamp, epoch seconds
    local expire_datetime       # expiration timestamp, date/time format
    local msg

    if [[ $(grep "gcreds" ~/.aws/credentials) ]]; then

        # title header
        msg="\n${BOLD}${accent}Temporary Amazon STS Credentials Generated${reset}${UNBOLD}\n"
        echo -e $msg | indent02

        # temporary credential iam names from local awscli config
        display_credential_profilenames "$HOME/.aws/credentials"

        if [[ -e $config_path/credential.expiration ]]; then
            expire=$(cat $config_path/credential.expiration 2>/dev/null)
            credential_life=$(( $expire - $(date +%s) ))
        else
            credential_life=0
        fi

        # branch if expired credentials
        if [ $credential_life -le 0 ]; then
            # Credentials have expired
            echo -e "\n    Your credentials have ${red}expired${reset}.\n" | indent02
        else
            # valid sts temp crednetials; print session stats, auto refresh of credentials
            if [ $session_life ]; then
                ## show credential stats ##
                expire_datetime=$(date --date=@$(cat $config_path/credential.expiration 2>/dev/null))
                min_left=$(( $credential_life/60 ))    # convert timeleft from sec to min
                if [ $session_life -gt $CREDENTIAL_DEFAULT ]; then
                    echo -e "\nCredential refresh in ${BOLD}${accent}$min_left${reset}${UNBOLD} minutes." | indent02
                    echo -e "Refresh Time: $expire_datetime\n" | indent02
                else
                    # creds will not be refreshed, not enough time remaining in session
                    echo -e "\nCredential expiration in ${BOLD}${accent}$min_left${reset}${UNBOLD} minutes." | indent02
                    echo -e "Expiration Time: $expire_datetime\n" | indent02
                fi

                ## show session stats ##
                expire_datetime=$(date --date=@$(cat $config_path/token.expiration  2>/dev/null))
                #
                if [ $session_life -le 60 ]; then
                    min_left=$(( $session_life ))    # convert timeleft from sec to min
                    echo -e "Session Expiration in ${BOLD}${accent}$min_left${reset}${UNBOLD} minutes." | indent02
                else
                    # session_life > 1 hr
                    secs_left=$(( $session_life*60 ))    # convert timeleft
                    hrs_left=$(printf '%d\n' $(($secs_left/3600)))
                    min_left=$(printf '%d\n' $(($secs_left%3600/60)))
                    echo -e "Session Expiration in ${BOLD}${accent}$hrs_left${reset}${UNBOLD} hours ${BOLD}${accent}$min_left${reset}${UNBOLD} minutes." | indent02
                fi
                echo -e "Expiration Time: $expire_datetime\n" | indent02
                echo -e "         ----" | indent10
                echo -e "\n${BOLD}$pkg${UNBOLD} Auto-refesh mode." | indent10
                echo -e "   ctrl+c to quit before session end\n" | indent02
            else
                # no extended session, show temp credential stats only
                expire_datetime=$(date --date=@$(cat $config_path/credential.expiration 2>/dev/null))
                min_left=$(( $credential_life/60 ))    # convert timeleft from sec to min
                echo -e "\nCredential Expiration in ${BOLD}${accent}$min_left${reset}${UNBOLD} minutes." | indent02
                echo -e "Expiration Time: $expire_datetime\n" | indent02
            fi
        fi
    else
        # no existing credentials
        std_message "Your local configuration does not contain credentials." INFO
    fi
    #
    # <-- end function gcreds_show_creds -->
}

function gcreds_source_config(){
    ## source local $pkg configuration options ##
    local choice
    local log_msg
    #
    if [[ -e $config_path/$gcreds_conf ]]; then

        MFA_PROFILE=$(cat $config_path/$gcreds_conf | jq -r .default_profile)
        COLOR_SCHEME=$(cat $config_path/$gcreds_conf | jq -r .default_color)

        # validate config values
        if [ $MFA_PROFILE == null ] || [ $COLOR_SCHEME == null ]; then
            std_warn "Problem reading $pkg config parameters."
            read -p "${yellow}  Do you want to configure $pkg? [yes]:${reset} " choice
            if [ -z $choice ] || [ $choice == 'yes' ]; then
                gcreds_configure
            else
                return 0
            fi
        fi

        # set color scheme
        case $COLOR_SCHEME in
            LTDB)
                accent=$(tput setaf 7)      # white
                log_msg="LTDB"
                ;;
            DTLB)
                accent=$(tput setaf 008)    # dark gray
                log_msg="DTLB"
                ;;
            BLUE)
                accent=$(tput setaf 4)      # blue
                log_msg="BLUE"
                ;;
            GREEN)
                accent=$(tput setaf 2)      # green
                log_msg="GREEN"
                ;;
            ORNG)
                accent=$(echo -e ${orange})      # bright orange (ansi)
                log_msg="ORNG"
                ;;
        esac
        # log
        std_logger "[INFO]: gcreds_source_config: MFA_PROFILE = $MFA_PROFILE"
        std_logger "[INFO]: gcreds_source_config: COLOR_SCHEME = $log_msg"
    fi
    #
    # <-- end function gcreds_source_config -->
}

function gcreds_test(){
    ## output for testing purposes only ##
    echo -e "\nACCTFILE: "$ACCTFILE
    echo -e "MFA_PROFILE: "$MFA_PROFILE
    echo -e "MFA_CODE: "$MFA_CODE
    echo -e "TOKEN_LIFE: $TOKEN_LIFE minutes"
    echo -e "MFA_ARN: $MFA_ARN\n"
    exit 0
    #
    # <-- end function greds_test
}

function gcreds_update_expiration(){
    # timestamps for tracking credential expiration
    # state Legend:
    #       0 = clear credential expiration
    #       1 = new credential expiration
    #       2 = expire expiration, but keep config files (not used)
    local state=$1
    #
    if [ $1 == 0 ] && [ -e $config_path/credential.expiration ]; then
        rm $config_path/credential.*
        std_logger "[INFO]: Credential expiration values cleared"
    elif [[ $1 == 1 ]]; then
        echo $(date +%s) > $config_path/credential.start
        EXPIRE=$(( $(($CREDENTIAL_DEFAULT*60)) + $(date +%s) ))
        echo $EXPIRE > $config_path/credential.expiration
        std_logger "[INFO]: Created new credential expiration values in $config_path"
    fi
    #
    # <-- end function gcreds_update_expiration -->
}

function gcreds_validate_parameter(){
    ## validate parameter type, integer or decimal ##
    #
    local parameter=$1          # parameter value to validate range
    local type=$2               # type of value expected
    local msg_description="$3"  # error msg leading description
    local min_value=$4          # min value in range
    local max_value=$5          # max value in range
    local units="$6"            # units, min_value (minutes, lbs, kg, etc)
    #
    case $type in
        int)
            # integer required
            if ! [[ $parameter =~ ^[0-9]+$ ]]; then
                # parameter is not integer
                std_error_exit "$msg_description must be an integer. Exiting (code $E_BADARG)" $E_BADARG
            fi
            ;;
        float)
            # floating pt decimal required
            if [[ $parameter =~ ^[0-9]+$ ]]; then
                # parameter is integer
                std_error_exit "$msg_description must be a floating point decimal. Exiting (code $E_BADARG)" $E_BADARG
            fi
            ;;
        *)
            # Unrecognized type
            std_error_exit "Unrecognized argument in gcreds_validate_parameter [ $type ]. \
            Exiting (code $E_BADARG)" $E_BADARG
            ;;
    esac
    ## validate range, if limits given ##
    if [ $4 ] && [ $5 ] && [ $6 ]; then
        if [[ $parameter -lt $min_value ]]; then
            # timeout < sts minimum limit
            std_error_exit "$msg_description must be $min_value $units or more. Exiting (code $E_BADARG)" $E_BADARG
        elif [[ $parameter -gt $max_value ]]; then
            # timeout is > sts maximum
            std_error_exit "$msg_description must be less than $max_value $units. Exiting (code $E_BADARG)" $E_BADARG
        fi
    fi
    #
    #<-- end function gcreds_validate_parameter -->
}

function gcreds_generate_token() {
    ## get session token using primary IAM user (MFA_PROFILE) ##
    std_logger "[INFO]: Generate session token for iam profile [gcreds-$MFA_PROFILE]"
    #
    # generate temp creds for MFA_PROFILE
    aws sts get-session-token \
        --duration-seconds $(($TOKEN_LIFE*60)) \
        --serial-number "$MFA_ARN" \
        --token-code "$MFA_CODE" \
        --output json \
        --profile $MFA_PROFILE 2>/dev/null > $TMPDIR/.aua.creds.json

    # create temp profile
    AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId $TMPDIR/.aua.creds.json)
    AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey $TMPDIR/.aua.creds.json)
    AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken $TMPDIR/.aua.creds.json)

    # validate authentication
    gcreds_authentication $AWS_ACCESS_KEY $AWS_SECRET_KEY $AWS_SESSION_TOKEN

    echo " " > $TMPDIR/.session.profile
    echo "[gcreds-$MFA_PROFILE]" >> $TMPDIR/.session.profile
    echo "aws_access_key_id = $AWS_ACCESS_KEY" >> $TMPDIR/.session.profile
    echo "aws_secret_access_key = $AWS_SECRET_KEY" >> $TMPDIR/.session.profile
    echo "aws_security_token = $AWS_SESSION_TOKEN" >> $TMPDIR/.session.profile
    cat $TMPDIR/.session.profile >> ~/.aws/credentials

    # record token lifetime start, end
    TOKEN_START=$(date +%s)     # epoch seconds
    echo $TOKEN_START > $config_path/token.start
    EXPIRE=$(( $(($TOKEN_LIFE*60)) + $TOKEN_START ))
    echo $EXPIRE > $config_path/token.expiration

    # store on disk for reuse if --auto parameter
    mv -f $TMPDIR/.session.profile $config_path/
    # clean up
    gcreds_clean .aua.creds.json
    #
    # <-- end function gcreds_generate_token -->
}

function gcreds_generate_creds(){
    ## generate actual credentials ##
    local role_arn
    local py3bin=$(which python3 2>/dev/null)
    #
    # sanity check on list of profile names provided to gcreds
    if ! valid_profilelist "$ACCTFILE"; then
        std_message "Invalid profilenames found. Exit" "INFO"
        $py3bin "$lib_path"/precheck-accounts.py --subset $ACCTFILE
        exit $E_DEPENDENCY
    fi
    #
    std_logger "[INFO]: Generating temp credentials for iam profile [gcreds-$MFA_PROFILE]"
    #
    # create temp credentials for each profile in ACCTFILE
    for profile in $(cat $ACCTFILE); do
        # assign arn from local config
        role_arn=$(aws configure get $profile.role_arn)

        if gcreds_profile_exists $role_arn; then
            echo -e "\nGenerating temp credentials for profile ${accent}${BOLD}$profile${reset}${UNBOLD}" | indent02
            echo -e "Assuming role: ${lgray}$role_arn${reset}\n" | indent02

            # call assume role to gen temp creds
            aws sts assume-role \
                --duration-seconds $(($CREDENTIAL_DEFAULT*60)) \
                --role-arn "$role_arn" \
                --role-session-name "gcreds-$profile" \
                --output json \
                --profile "gcreds-$MFA_PROFILE" > $TMPDIR/.creds.json

            # create temp profile
            AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId $TMPDIR/.creds.json)
            AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey $TMPDIR/.creds.json)
            AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken $TMPDIR/.creds.json)

            echo " " > $TMPDIR/.new.profile
            echo "[gcreds-$profile]" >> $TMPDIR/.new.profile
            echo "aws_access_key_id = $AWS_ACCESS_KEY" >> $TMPDIR/.new.profile
            echo "aws_secret_access_key = $AWS_SECRET_KEY" >> $TMPDIR/.new.profile
            echo "aws_security_token = $AWS_SESSION_TOKEN" >> $TMPDIR/.new.profile

            # add to local config
            cat $TMPDIR/.new.profile >> ~/.aws/credentials
            # success, log out
            std_logger "[INFO]: Generated temp credentials for role profile [gcreds-$profile]"
        fi
    done
    # update credential start, expiration value markers
    gcreds_update_expiration 1
    # log info about aws version used to generate creds
    gcreds_env_info "INFO" aws
    # clean up temp files
    gcreds_clean .creds.json .new.profile
    #
    # <-- end function gcreds_generate_creds -->
}

gcreds_monitor(){
    ## display session & credential lifetime remaining ##
    local delay=5                     # screen refresh delay, seconds
    local expire                      # expiration timestamp, epoch seconds
    local session_remaining           # time remaining in session, seconds
    local clear_bin=$(which clear)    # clear screen bin file
    #
    sleep $delay
    $clear_bin                        # clear screen

    # session time stats
    expire=$(cat $config_path/token.expiration)
    sec_left=$(( $expire - $(date +%s) ))
    SESSION_REMAINING=$(( $sec_left/60 ))   # session duration, minutes

    # credentials time stats
    expire=$(cat $config_path/credential.expiration 2>/dev/null)
    sec_left=$(( $expire - $(date +%s) ))
    CREDENTIAL_REMAINING=$(( $sec_left/60 ))

    # display
    gcreds_show_creds  $SESSION_REMAINING
    #
    # <-- end function gcreds-show-stats -->
}

function update_awscli(){
    ## update local awscli iam user credentials ##
    local choice                      # user selection
    local profile                     # valid profile in local awscli config
    local awscli_bin=$(which aws)     # aws binary
    local clear_bin=$(which clear)    # clear screen bin file
    local valid=0                     # loop
    #
    $clear_bin                        # clear screen
    cat<<EOM

                        ${BOLD}${accent}awscli${reset}${UNBOLD} update menu

    You have entered the $pkg menu for updating Identity and Access
    Management user credentials in your local awscli configuration.

    Since $pkg modifies your awscli configuration, this facility is
    the safest way to make required updates to iam user config data
    without risk of corruption.

    $pkg will start by clearing all temporary credentials from your
    local config.

    Type ${yellow}y${reset} when you are ready to begin. Hit ${yellow}return${reset} to quit.


EOM
    read -p "${yellow}    Continue? [quit]:${reset} " choice
    if [ -z $choice ] || [ $choice == 'quit' ]; then
        echo -e '\n'
        exit 0
    fi

    # check if temp credentials; if yes, clear them
    if ! gcreds_preexisting_creds; then
        std_message "No temporary credentials found in your local config" INFO
    fi

    # clear credentials backup copy to prevent deprecated creds from being restored
    rm ~/.aws/*.orig

    # print out env stats
    echo -e "\n${BOLD}${accent}awscli${UNBOLD}${reset} config stats:\n" | indent04
    gcreds_env_info INFO "awscli"; echo -e "\n"

    # loop until given valid iam user in local config
    while [ $valid -eq 0 ]; do
        echo -e "\n  What is the iam username associated with the awscli profile" | indent02
        echo -e "  you wish to update?  Hit ${yellow}return${reset} if you want to update the" | indent02
        echo -e "  default profile.\n" | indent02
        read -p "${yellow}    iam username to update [default]: ${reset}" choice
        echo -e '\n'

        if [ -z $choice ]; then
            profile='default'
        else
            profile="$choice"
        fi
        # validate username in local config
        key=$(aws configure get "$profile".aws_access_key_id)
        if [ ! $key ]; then
            std_message "Profile name ($profile) not in your local config. " ERROR
        else
            valid=1
        fi
    done
    echo -e "\nUpdating credentials for iam user: ${red}${BOLD}$profile${UNBOLD}:"${orange}"\n"
    if [ $profile == 'default' ]; then
        $awscli_bin configure
    else
        $awscli_bin configure --profile "$profile"
    fi

    # create new credential backup copy
    gcreds_backup
    # print footer
    std_message "${reset}awscli configuration update complete" INFO
    #
    # <-- end function update_awscli -->
}


function valid_profilelist(){
    ##
    ##  check the list of profile names for duplicates
    ##  and names missing from local awscli configuration
    ##
    local acctfile="$1"
    local py3bin

    py3bin=$(command -v python3 2>/dev/null)
    #
    if [ "$($py3bin "$lib_path"/precheck-accounts.py --subset "$acctfile" >/dev/null; echo $?)" = "1" ]; then
        return 0
    else
        return 1
    fi
}


#
#<-- start MAIN ----------------------(do not modify this line)----------------
#

# check deps
gcreds_depcheck

# verify backup of existing awscli config
gcreds_backup

# parse inputs
gcreds_parse_parameters $@

# check for active temp credentials before generating new creds
gcreds_preexisting_creds

# generate session token
gcreds_generate_token

# generate temporary credentials
gcreds_generate_creds

if [ $MONITOR == False ]; then
    gcreds_show_creds
else
    while [ $MONITOR == True ]; do
        #
        # calc and display stats
        gcreds_monitor
        #
        if [ $CREDENTIAL_REMAINING -lt 1 ] && [ $SESSION_REMAINING -gt $CREDENTIAL_DEFAULT ]; then
            #
            # clear out expiring creds
            gcreds_remove_creds -s
            # reset session credentials
            cat $config_path/.session.profile >> ~/.aws/credentials
            # generate credentials
            gcreds_generate_creds
            #
        elif [ $CREDENTIAL_REMAINING -lt 0 ] && [ $SESSION_REMAINING -le $CREDENTIAL_DEFAULT ]; then
            std_message "$pkg session end" INFO
            MONITOR=False
        fi
    done
fi

# clean out token, .session.profile from config_path (credential.expiration persist)
rm $config_path/.session.profile $config_path/token.*

#
#<-- end MAIN -----------------------------------------------------------------
#
exit 0
