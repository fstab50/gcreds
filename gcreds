#!/bin/bash

# global variables
pkg=$(basename $0)
pkg_path=$(cd $(dirname $0); pwd -P)
pwd_path=$(pwd)
config_path="$HOME/.$pkg"
gcreds_log="$pkg_path/logs/gcreds.log"
host=$(hostname)
system=$(uname)
DBUGMODE=""          # change this value to "True" to turn on verbose \
                      # log output to aid debugging

# Amazon Sercurity Token Service (STS) limits
STS_MIN=15            # minutes, STS min allowed value
STS_MAX=600           # minutes, STS max equivalent to 10 hours
TOKEN_DEFAULT=60      # minutes, default STS session token lifetime
CREDENTIAL_DEFAULT=60 # minutes, default lifetime of temp credentials generated

# error codes
E_DEPENDENCY=1        # exit code if missing required dependency
E_DIR=2               # exit code if failure to create log dir, log file
E_BADSHELL=3          # exit code if incorrect shell detected
E_AUTHFAIL=5          # exit code if authentication failure
E_BADPROFILE=6        # exit code if profile name/ role not found in local config
E_USER_CANCEL=7       # exit code if user cancel
E_BADARG=8            # exit code if bad input parameter
E_EXPIRED_CREDS=9     # exit code if temporary credentials no longer valid
E_MISC=11             # exit code if miscellaneous (unspecified) error

# Formatting
blue=$(tput setaf 4)
cyan=$(tput setaf 6)
green=$(tput setaf 2)
purple=$(tput setaf 5)
red=$(tput setaf 1)
white=$(tput setaf 7)
yellow=$(tput setaf 3)
orange='\033[0;33m'
gray=$(tput setaf 008)
lgray='\033[0;37m'    # light gray
dgray='\033[1;30m'    # dark gray
reset=$(tput sgr0)
#
BOLD=`tput bold`
UNBOLD=`tput sgr0`

#
# function declaration start --------------(do not modify this line)-----------
#

# indent
indent02() { sed 's/^/  /'; }
indent10() { sed 's/^/          /'; }

function gcreds_help(){
    cat <<EOM

 Help Contents
 -------------

    To generate temporary credentials:

    ${white}${BOLD}Usage${UNBOLD}${reset} : $pkg -a <ACCTFILE> --profile <IAM_PROFILE> -c <MFA_CODE>

    ${white}${BOLD}OPTIONS${UNBOLD}${reset} :
         -a, --accounts : list of accounts, see ACCTFILE
         -p, --profile  : iam user account, see IAM_PROFILE
         -c, --mfa-code : authentication code, see MFA_CODE
        [-A, --auto     : auto refresh credentials]
        [-s, --show     : show credential expiration info]
        [-h, --help     : display this help menu]

    ${white}${BOLD}ACCTFILE${reset}${UNBOLD} (required)
        text file listing of profile names in your local awscli configuration,
        one per line. Profiles correspond to IAM roles in AWS accounts for
        which you wish to generate temporary credentials.

    ${white}${BOLD}IAM_PROFILE${reset}${UNBOLD} (required)
        profile name of the IAM user in your local awscli configuration that
        contains the ARN of the mfa_serial used to assume roles

    ${white}${BOLD}MFA_CODE${reset}${UNBOLD} (required)
        6 digit otp integer code from either a hardware or virtual mfa
        device MFA code must correspond to the IAM_PROFILE given

    ${white}${BOLD}-A | --auto ${reset}<${white}N${reset}>${UNBOLD} (optional)
        Auto refresh of temporary credentials for N hours.  If omitted,
        temporary credentials are generated only once and expire with
        default timeout = 60 min. N is an integer between 1 and 10
                                 -----------

        New profiles added to your awscli config prefixed with '${BOLD}gcreds-${UNBOLD}'

    ---------------------------------------------------------------------------

    To remove temporary credentials:

    ${white}${BOLD}Usage${UNBOLD}${reset} : $pkg -r

        -r, --revert  :  Clears temporary credentials from your local
                         awscli configuration, returning your config to
                         a pre-gcreds state.

EOM
    exit 0
    #
    #<-- end function gcreds_help -->
}

function gcreds_logger(){
    local msg="$1"
    if [[ ! $gcreds_log ]]; then
        echo "$pkg: failure to call gcreds_logger, $gcreds_log location undefined"
        exit $E_DIR
    fi
    echo "$(date +'%b %d %T') $host $pkg: $msg" >> "$gcreds_log"
}

function gcreds_message(){
    local msg="$1"
    gcreds_logger "[INFO]: $msg"
    [[ $quiet ]] && return
    shift
    pref="----"
    if [[ $1 ]]; then
        pref="${1:0:4}"
        shift
    fi
    echo -e "\n${yellow}[ $cyan$pref$yellow ]$reset  $msg\n" | indent02
}

function gcreds_error(){
    local msg="$1"
    gcreds_logger "[ERRR]: $msg"
    echo -e "\n${yellow}[ ${red}ERRR${yellow} ]$reset  $msg\n" | indent02
}

function gcreds_warn(){
    local msg="$1"
    gcreds_logger "[WARN]: $msg"
    if [ "$3" ]; then
        # there is a second line of the msg, to be printed by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg" | indent02
    else
        # msg is only 1 line sent by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg\n" | indent02
    fi
}

function gcreds_error_exit(){
    local msg="$1"
    local status="$2"
    gcreds_error "$msg"
    exit $status
}

function gcreds_env_info(){
    local msg_header=$1
    local dep=$2

    if [[ $dep == "aws" ]]; then
        version_info=$(aws --version 2>&1)
        gcreds_logger "[$msg_header]: awscli version detected: $(echo $version_info | awk '{print $1}')"
        gcreds_logger "[$msg_header]: Python version detected: $(echo $version_info | awk '{print $2}')"
        gcreds_logger "[$msg_header]: Kernel detected: $(echo $version_info | awk '{print $3}')"
        gcreds_logger "[$msg_header]: awscli library detected: $(echo $version_info | awk '{print $4}')"
    elif [[ $dep == "jq" ]]; then
        version_info=$(jq --version 2>&1)
        gcreds_logger "[$msg_header]: json parser detected: $(echo $version_info)"
    else
        gcreds_logger "[$msg_header]: detected: $($prog --version | head -1)"
    fi
    #
    #<-- end function gcreds_env_info -->
}

function gcreds_depcheck(){
    ## test default shell ##
    if [ ! -n "$BASH" ]; then
        # shell other than bash
        gcreds_error_exit "Default shell appears to be something other than bash. Please rerun with bash. Aborting (code $E_BADSHELL)" $E_BADSHELL
    fi
    ## create log dir for gcreds ##
    if [[ ! -d $pkg_path/logs ]]; then
        if ! mkdir -p "$pkg_path/logs"; then
            gcreds_error_exit "$pkg: failed to make log directory: $pkg_path/logs" $E_DIR
        fi
    fi
    ## create gcreds config dir ##
    if [[ ! -d $config_path ]]; then
        gcreds_warn "config_path not found, creating config dir $config_path"
        if ! mkdir -p $config_path; then
            gcreds_error_exit "$pkg: failed to create local config file directory: ~/.$pkg" $E_DIR
        fi
    fi
    ## check for required cli tools ##
    for prog in aws jq date hostname awk grep cat; do
        if ! type "$prog" > /dev/null 2>&1; then
            gcreds_error_exit "$prog is required and not found in the PATH. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
        if [ $DBUGMODE ]; then
            gcreds_env_info "DBUG" $prog
        fi
    done
    ## check if awscli tools are configured ##
    if [[ ! -f $HOME/.aws/config ]]; then
        gcreds_error_exit "awscli not configured, run 'aws configure'. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
    fi
    ## check for jq, use system installed version if found, otherwise use bundled ##
    if which jq > /dev/null; then
        jq=$(which jq)
    else
        jq="assets/jq/$system/jq"
        if [[ ! -f $jq ]]; then
            gcreds_error_exit "no viable json parser binary (jq) found, Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
    fi
    ## set temp to writeable location in physical memory ##
    df=$(which df)
    if [ "$($df /run 2>/dev/null | awk '{print $1, $6}' | grep tmpfs 2>/dev/null)" ]; then
            # in-memory
            TMPDIR="/dev/shm"
    else
            TMPDIR="/tmp"
    fi
    #
    # <-- end function gcreds_depcheck -->
}

function gcreds_authentication(){
    # validate authenthentication to aws apis before writing to awscli config
    if [ ! $1 ] || [ ! $2 ] || [ ! $3 ]; then
        # authenication failed, most likely invalid mfa token
        gcreds_clean .aua.creds.json
        gcreds_error_exit "Authentication Failure: MFA code incorrect. (code $E_AUTHFAIL)" $E_AUTHFAIL
    fi
    #
    #<-- end function gcreds_authentication -->
}

function gcreds_backup(){
    # backup existing awscli config
    if [[ ! -e ~/.aws/credentials.orig ]]; then
        # no config bkup, create
        cp ~/.aws/credentials ~/.aws/credentials.orig
    fi
    #
    #<-- end functions gcreds_backup -->
}

function gcreds_clean(){
    # delete all files given as parameters
    if [[ $1 = .* ]]; then
        # temp files
        cd $TMPDIR
        rm $@
        cd $pwd_path
    else
        rm $@
    fi
    #
    #<-- end function gcreds_clean -->
}

function gcreds_profile_exists(){
    # validate if profile exists in local awscli config
    if [[ $1 == "" ]] && [[ $1 == $MFA_ARN ]]; then
        gcreds_error "Invalid MFA profile name provided ($MFA_PROFILE) Exiting code $E_BADARG." $E_BADARG
        gcreds_help
    elif [[ $1 == "" ]]; then
        gcreds_warn "Profile name ($profile) not in your local config. (code $E_BADPROFILE)." $E_BADPROFILE
        return 1
    fi
    #
    #<-- end function gcreds_profile_exists -->
}

function gcreds_parse_parameters(){
    ## help requested ##
    if [[ ! $@ ]]; then
        # display help
        gcreds_help
    else
        while [ $# -gt 0 ]; do
            case $1 in
                -h | --help | -help)
                    # display help
                    gcreds_help
                    ;;
                -r | --revert | -revert | --Revert)
                    revert=1    # flag indicating direct call to clear config
                    if ! gcreds_preexisting_creds $revert; then
                        gcreds_message "You do not have temporary credentials in your config. Nothing to do." INFO
                    fi
                    exit 0
                    ;;
                -a | --accounts | *.accounts | *.accts)
                    # list of accts to gen temp creds, one per line
                    # -f, --file, *.accounts, *.accts for backward compatibility
                    if [ $1 == "-a" ] || [ $1 == "--accounts" ]; then
                        ACCTFILE=$2
                        shift 2
                    fi
                    ;;
                -p | --profile)
                    # iam user profile used to assume roles
                    if [ $2 ]; then
                        MFA_PROFILE=$2
                        shift 2
                    else
                        gcreds_error_exit "You must provide an IAM profile name. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                --mfa-code | --mfacode | --mfa | --code | -c)
                    # otp code from virtual or hw mfa device. verify 6 digit int
                    if [[ $2 =~ ^[0-9]{6}$ ]]; then
                        MFA_CODE=$2
                        shift 2
                    else
                        gcreds_error_exit "You must enter a valid 6 digit mfa code. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                -s | --show)
                    # display info on current credentials, if exist
                    gcreds_show_creds
                    shift 1
                    exit 0
                    ;;
                -A | --auto)     # optional
                    if [ $2 ]; then
                        # $2 given in hours
                        TIMEOUT=$(( $2*60 ))
                        shift 2
                    else
                        gcreds_error_exit "You must provide a timeout value. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                *)
                    # invalid argument
                    gcreds_error_exit "Unrecognized argument [ $1 ] given. Exiting (code $E_BADARG)" $E_BADARG
            esac
        done
    fi
    ## check that min required parameters have been supplied ##
    if [ ! $ACCTFILE ]; then
        gcreds_error "You must provide an account list, exiting (code $E_BADARG)." $E_BADARG
        gcreds_help
    fi
    if [ ! $MFA_PROFILE ]; then
        gcreds_error "You must enter an IAM user used to assume roles. Exiting (code $E_BADARG)" $E_BADARG
        gcreds_help
    fi
    if [ ! $MFA_CODE ]; then
        gcreds_error "You must enter a valid 6 digit mfa code. Exiting (code $E_BADARG)" $E_BADARG
        gcreds_help
    fi

    # set remaining assignments
    MFA_ARN=$(aws configure get $MFA_PROFILE.mfa_serial)
    # verify valid mfa_profile
    gcreds_profile_exists $MFA_ARN

    # set timeout
    if [[ ! $TIMEOUT ]]; then
        TIMEOUT=$TOKEN_DEFAULT  # default token expiration (minutes)
    else
        gcreds_validate_parameter $TIMEOUT int "Temp credential lifetime" $STS_MIN $STS_MAX "minutes"
    fi
    #
    # <-- end function gcreds_parse_parameters -->
}

function gcreds_preexisting_creds(){
    # verify existence of previous temp credentials
    if [[ $(grep "gcreds" ~/.aws/credentials) ]]; then
        if [ ! $1 ]; then
            # not a direct call via revert parameter
            line2=1     # flag indicating a 2 line msg
            gcreds_warn "You appear to have active temp credentials already in your local config." WARN $line2
            echo -e "These should be cleared before generating new credentials." | indent10
            # clear active creds by restoring from backup, silent mode
            gcreds_revert_creds -s
        else
            # clear active creds by restoring from backup, interactive mode
            gcreds_revert_creds
        fi
        # restor backup of awscli
        gcreds_backup
    else
        # no preexisting credentials in local config
        return 1
    fi
    #
    #<-- end function gcreds_preexisting_creds -->
}

function gcreds_revert_creds(){
    ## deletes temp credentials from local awscli config ##
    #
    local silent=$1
    #
    # log out start
    gcreds_logger "[INFO]: Attempting to remove temp credentials from local config"
    # header
    echo -e "\n--${white}${BOLD} CLEARING LOCAL CONFIG ${UNBOLD}${reset}--\n" | indent10
    echo -e "All temp credentials from your local config will be discarded." | indent02
    echo -e "Your local awscli config will be returned to previous (clean) state.\n" | indent02
    if [ $silent ]; then
        # clean config, no user input
        CHOICE="y"
    else
        read -p "  ${yellow}Purge existing temporary credentials?${reset} [y]:  " CHOICE
    fi
    if [[ -z "$CHOICE" ]] || [[ "$CHOICE" == "y" ]] || [[ "$CHOICE" == "yes" ]]; then
        # restore clean config from backup
        if [[ -e ~/.aws/credentials.orig ]]; then
            mv ~/.aws/credentials.orig ~/.aws/credentials
            gcreds_message "Your local config has been cleaned." INFO
            # clear existing credential expiration values
            gcreds_update_expiration 0
        else
            # no backup exists, clean
            gcreds_message "Nothing done. Your config appears to be clean already." INFO
        fi
    else
        gcreds_message "Temporary credentials remain in your config. Nothing done." INFO
    fi
    #
    # <-- end function gcreds_revert_creds -->
}

function gcreds_show_creds(){
    ## display credentials in local config ##
    local session_life="$1"     # time remaining in session, seconds
    local credential_life       # seconds until temporary credential expire
    local hrs_left              # duration before expiration, hours
    local min_left              # duration before expiration, min
    local expire                # expiration timestamp, epoch seconds
    local expire_datetime       # expiration timestamp, date/time format
    local msg
    #
    if [[ $(grep "gcreds" ~/.aws/credentials) ]]; then
        msg="\n${BOLD}${white}Temporary Credentials in local config:${reset}${UNBOLD}\n"
        echo -e $msg | indent02
        grep --color=auto "gcreds" ~/.aws/credentials | indent10
        if [[ -e $config_path/credential.expiration ]]; then
            expire=$(cat $config_path/credential.expiration)
            credential_life=$(( $expire - $(date +%s) ))
        else
            credential_life=0
        fi
        if [ $credential_life -le 0 ]; then
            # Credentials have expired
            echo -e "\n    Your credentials have ${red}expired${reset}.\n" | indent02
        else
            # session stats, if auto refresh of credentials
            if [ $session_life ]; then
                # output session stats
                expire_datetime=$(date --date=@$(( $session_life + $(date +%s) )))
                #
                if [ $session_life -le 60 ]; then
                    min_left=$(( $session_life/60 ))    # convert timeleft from sec to min
                    echo -e "\nSession Expiration in ${BOLD}${white}$min_left${reset}${UNBOLD} minutes." | indent02
                else
                    # session_life > 1 hr
                    hrs_left=$(( $session_life/3600 ))    # convert timeleft
                    echo -e "\nSession Expiration in ${BOLD}${white}$hrs_left${reset}${UNBOLD} hours." | indent02
                fi
                echo -e "Expiration Time: $expire_datetime\n" | indent02
            fi
            # temp credential stats
            expire_datetime=$(date --date=@$(( $credential_life + $(date +%s) )))
            min_left=$(( $credential_life/60 ))    # convert timeleft from sec to min
            echo -e "\nCredential Expiration in ${BOLD}${white}$min_left${reset}${UNBOLD} minutes." | indent02
            echo -e "Expiration Time: $expire_datetime\n" | indent02
        fi
    else
        # no existing credentials
        gcreds_message "Your local configuration does not contain credentials." INFO
    fi
    #
    # <-- end function gcreds_show_creds -->
}

function gcreds_test(){
    ## output for testing purposes only ##
    echo -e "\nACCTFILE: "$ACCTFILE
    echo -e "MFA_PROFILE: "$MFA_PROFILE
    echo -e "MFA_CODE: "$MFA_CODE
    echo -e "TIMEOUT: $TIMEOUT minutes"
    echo -e "MFA_ARN: $MFA_ARN\n"
    exit 0
    #
    # <-- end function greds_test
}

function gcreds_update_expiration(){
    # timestamps for tracking credential expiration
    # state Legend:
    #       0 = clear credential expiration
    #       1 = new credential expiration
    #       2 = expire expiration, but keep config files (not used)
    local state=$1
    #
    if [[ $1 == 0 ]]; then
        rm $config_path/credential.*
        gcreds_logger "[INFO]: Credential expiration values cleared"
    elif [[ $1 == 1 ]]; then
        echo $(date +%s) > $config_path/credential.start
        EXPIRE=$(( $(($TIMEOUT*60)) + $(date +%s) ))
        echo $EXPIRE > $config_path/credential.expiration
        gcreds_logger "[INFO]: Created new credential expiration values in $config_path"
    fi
    #
    # <-- end function gcreds_update_expiration -->
}

function gcreds_validate_parameter(){
    ## validate parameter type, integer or decimal ##
    #
    local parameter=$1          # parameter value to validate range
    local type=$2               # type of value expected
    local msg_description="$3"  # error msg leading description
    local min_value=$4          # min value in range
    local max_value=$5          # max value in range
    local units="$6"            # units, min_value (minutes, lbs, kg, etc)
    #
    case $type in
        int)
            # integer required
            if ! [[ $parameter =~ ^[0-9]+$ ]]; then
                # parameter is not integer
                gcreds_error_exit "$msg_description must be an integer. Exiting (code $E_BADARG)" $E_BADARG
            fi
            ;;
        float)
            # floating pt decimal required
            if [[ $parameter =~ ^[0-9]+$ ]]; then
                # parameter is integer
                gcreds_error_exit "$msg_description must be a floating point decimal. Exiting (code $E_BADARG)" $E_BADARG
            fi
            ;;
        *)
            # Unrecognized type
            gcreds_error_exit "Unrecognized argument in gcreds_validate_parameter [ $type ]. \
            Exiting (code $E_BADARG)" $E_BADARG
            ;;
    esac
    ## validate range, if limits given ##
    if [ $4 ] && [ $5 ] && [ $6 ]; then
        if [[ $parameter -lt $min_value ]]; then
            # timeout < sts minimum limit
            gcreds_error_exit "$msg_description must be $min_value $units or more. Exiting (code $E_BADARG)" $E_BADARG
        elif [[ $parameter -gt $max_value ]]; then
            # timeout is > sts maximum
            gcreds_error_exit "$msg_description must be less than $max_value $units. Exiting (code $E_BADARG)" $E_BADARG
        fi
    fi
    #
    #<-- end function gcreds_validate_parameter -->
}

function gcreds_generate_token() {
    ## get session token using primary IAM user (MFA_PROFILE) ##
    gcreds_logger "[INFO]: Generate session token for iam profile [gcreds-$MFA_PROFILE]"
    #
    # generate temp creds for MFA_PROFILE
    aws sts get-session-token \
        --duration-seconds $(($TIMEOUT*60)) \
        --serial-number "$MFA_ARN" \
        --token-code "$MFA_CODE" \
        --output json \
        --profile $MFA_PROFILE 2>/dev/null > $TMPDIR/.aua.creds.json

    # create temp profile
    AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId $TMPDIR/.aua.creds.json)
    AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey $TMPDIR/.aua.creds.json)
    AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken $TMPDIR/.aua.creds.json)

    # validate authentication
    gcreds_authentication $AWS_ACCESS_KEY $AWS_SECRET_KEY $AWS_SESSION_TOKEN

    echo " " > $TMPDIR/.session.profile
    echo "[gcreds-$MFA_PROFILE]" >> $TMPDIR/.session.profile
    echo "aws_access_key_id = $AWS_ACCESS_KEY" >> $TMPDIR/.session.profile
    echo "aws_secret_access_key = $AWS_SECRET_KEY" >> $TMPDIR/.session.profile
    echo "aws_security_token = $AWS_SESSION_TOKEN" >> $TMPDIR/.session.profile
    cat $TMPDIR/.session.profile >> ~/.aws/credentials

    # record token lifetime start, end
    TOKEN_START=$(date +%s)
    echo $TOKEN_START > $config_path/token.start
    EXPIRE=$(( $(($TIMEOUT*60)) + $TOKEN_START ))
    echo $EXPIRE > $config_path/token.expiration

    # store on disk for reuse if --auto parameter
    #if [ ! -e $config_path/.session.profile ]; then
        mv -f $TMPDIR/.session.profile $config_path/
    #fi
    # clean up
    gcreds_clean .aua.creds.json
    #
    # <-- end function gcreds_generate_token -->
}

function gcreds_generate_creds(){
    ## generate actual credentials ##
    gcreds_logger "[INFO]: Generated temp credentials for iam profile [gcreds-$MFA_PROFILE]"
    #
    # create temp credentials for each profile in ACCTFILE
    for profile in $(cat $ACCTFILE); do
        # assign arn from local config
        role_arn=$(aws configure get $profile.role_arn)

        if gcreds_profile_exists $role_arn; then
            echo -e "\nGenerating temp credentials for profile ${white}${BOLD}$profile${reset}${UNBOLD}" | indent02
            echo -e "Assuming role: ${lgray}$role_arn${reset}\n" | indent02

            # call assume role to gen temp creds
            aws sts assume-role \
                --duration-seconds $(($CREDENTIAL_DEFAULT*60)) \
                --role-arn "$role_arn" \
                --role-session-name "gcreds-$profile" \
                --output json \
                --profile "gcreds-$MFA_PROFILE" > $TMPDIR/.creds.json

            # create temp profile
            AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId $TMPDIR/.creds.json)
            AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey $TMPDIR/.creds.json)
            AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken $TMPDIR/.creds.json)

            echo " " > $TMPDIR/.new.profile
            echo "[gcreds-$profile]" >> $TMPDIR/.new.profile
            echo "aws_access_key_id = $AWS_ACCESS_KEY" >> $TMPDIR/.new.profile
            echo "aws_secret_access_key = $AWS_SECRET_KEY" >> $TMPDIR/.new.profile
            echo "aws_security_token = $AWS_SESSION_TOKEN" >> $TMPDIR/.new.profile

            # add to local config
            cat $TMPDIR/.new.profile >> ~/.aws/credentials
            # success, log out
            gcreds_logger "[INFO]: Generated temp credentials for role profile [gcreds-$profile]"
        fi
    done
    gcreds_update_expiration 1
    gcreds_show_creds
    # log info about aws version used to generate creds
    gcreds_env_info "INFO" aws
    # clean up temp files
    gcreds_clean .creds.json .new.profile
    # set monitoring bit
    MONITOR='True'
    #
    # <-- end function gcreds_generate_creds -->
}

gcreds_monitor(){
    ## display session & credential lifetime remaining ##
    local delay=3               # screen refresh delay, seconds
    local expire                # expiration timestamp, epoch seconds
    local session_remaining     # time remaining in session, seconds
    #
    sleep $delay
    # clear screen
    clear_bin=$(which clear)
    $clear_bin

    # session time stats
    expire=$(cat $config_path/token.expiration)
    sec_left=$(( $expire - $(date +%s) ))
    SESSION_REMAINING=$(( $sec_left/60 ))

    # credentials time stats
    expire=$(cat $config_path/credential.expiration)
    sec_left=$(( $expire - $(date +%s) ))
    CREDENTIAL_REMAINING=$(( $sec_left/60 ))

    # display
    gcreds_show_creds  $SESSION_REMAINING
    #
    # <-- end function gcreds-show-stats -->
}

#
#<-- start MAIN ----------------------(do not modify this line)----------------
#

# check deps
gcreds_depcheck

# verify backup of existing awscli config
gcreds_backup

# parse inputs
gcreds_parse_parameters $@

# check for active temp credentials before generating new creds
gcreds_preexisting_creds

# generate session token
gcreds_generate_token

# generate temporary credentials
gcreds_generate_creds

while [ $MONITOR == 'True' ]; do
    #
    # calc and display stats
    gcreds_monitor
    #
    if [ $CREDENTIAL_REMAINING -lt 1 ] && [ $SESSION_REMAINING -gt 60 ]; then
        #
        # clear out expiring creds
        gcreds_revert_creds -s
        # reset session credentials
        cat $config_path/session.profile >> ~/.aws/credentials
        # generate credentials
        gcreds_generate_creds
        #
    elif [ $CREDENTIAL_REMAINING -le 1 ] && [ $SESSION_REMAINING -le 60 ]; then
        gcreds_message "set MONITOR = False" INFO
        # clean out token, .session.profile from config_path
        rm $config_path/.session.profile $config_path/token.*
        MONITOR='False'
    fi
done

#
#<-- end MAIN -----------------------------------------------------------------
#
exit 0
