#!/bin/bash

# global variables
pkg=$(basename $0)
pkg_path=$(cd $(dirname $0); pwd -P)
gcreds_log="$pkg_path/logs/gcreds.log"
host=$(hostname)
system=$(uname)
debugMode=""    # change this value to "True" to turn on verbose \
                # log output to aid debugging

# Amazon Sercurity Token Service (STS) limits
STS_MIN=15      # minutes, equivalent to 900 seconds
STS_MAX=2160    # minutes, equivalent to 36 hours

# error codes
E_DEPENDENCY=1                # exit code if missing required dependency
E_NOLOG=2                     # exit code if failure to create log dir, log file
E_BADSHELL=3                  # exit code if incorrect shell detected
E_AUTHFAIL=5                  # exit code if authentication failure
E_BADPROFILE=6                # exit code if profile name/ role not found in local config
E_USER_CANCEL=7               # exit code if user cancel
E_BADARG=8                    # exit code if bad input parameter
E_MISC=11                     # exit code if miscellaneous (unspecified) error

# Formatting
blue=$(tput setaf 4)
cyan=$(tput setaf 6)
green=$(tput setaf 2)
purple=$(tput setaf 5)
red=$(tput setaf 1)
white=$(tput setaf 7)
yellow=$(tput setaf 3)
gray=$(tput setaf 008)
lgray='\033[0;37m'      # light gray
dgray='\033[1;30m'       # dark gray
reset=$(tput sgr0)
#
BOLD=`tput bold`
UNBOLD=`tput sgr0`

#<-- function declaration -->

# indent
indent02() { sed 's/^/  /'; }
indent10() { sed 's/^/          /'; }

function gcreds-help(){
    cat <<EOM

 Help Contents
 -------------

    To generate temporary credentials:

    ${white}${BOLD}Usage${UNBOLD}${reset} :
        $pkg [OPTION] [*.accounts] --profile [IAM_PROFILE] --mfa-code [MFA_CODE]

    ${white}${BOLD}Options${UNBOLD}${reset} :
        -t, --timeout :  temp credential expiration in minutes (15 minute default)

    <${white}${BOLD}filename$reset$UNBOLD>$white$BOLD.accounts${reset}${UNBOLD} (required)
        text file listing of profile names in your local awscli configuration, one
        per line corresponding to IAM roles and accounts for which you wish to
        generate temporary credentials. File must be located in gcreds root directory

    ${white}${BOLD}IAM_PROFILE${reset}${UNBOLD} (required)
        profile name of the IAM user in your local awscli configuration that
        contains the ARN of your mfa_serial used to assume roles

    ${white}${BOLD}MFA_CODE${reset}${UNBOLD} (required)
        6 digit otp code from either a hardware or virtual mfa device
        MFA code must correspond to the IAM_PROFILE given

                                 -----------

        New profiles added to your awscli config prepended with '${BOLD}gcreds-${UNBOLD}'

    ---------------------------------------------------------------------------

    To remove temporary credentials:

    ${white}${BOLD}Usage${UNBOLD}${reset} : $pkg [OPTION]

        -r, --revert  :  Clears temporary credentials from your local
                         awscli configuration, returning your config to
                         a pre-gcreds state.

EOM
    exit 0
    #
    #<-- end function gcreds-help -->
    #
}

function gcreds-logger(){
    local msg="$1"
    if [[ ! $gcreds_log ]]; then
        echo "$pkg: failure to call gcreds-logger, $gcreds_log location undefined"
        exit $E_NOLOG
    fi
    echo "$(date +'%b %d %T') $host $pkg: $msg" >> "$gcreds_log"
}

function gcreds-message(){
    local msg="$1"
    gcreds-logger "[INFO]: $msg"
    [[ $quiet ]] && return
    shift
    pref="----"
    if [[ $1 ]]; then
        pref="${1:0:4}"
        shift
    fi
    echo -e "\n${yellow}[ $cyan$pref$yellow ]$reset  $msg\n" | indent02
}

function gcreds-error(){
    local msg="$1"
    gcreds-logger "[ERRR]: $msg"
    echo -e "\n${yellow}[ ${red}ERRR${yellow} ]$reset  $msg\n" | indent02
}

function gcreds-warn(){
    local msg="$1"
    gcreds-logger "[WARN]: $msg"
    if [ "$3" ]; then
        # there is a second line of the msg, to be printed by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg" | indent02
    else
        # msg is only 1 line sent by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg\n" | indent02
    fi
}

function gcreds-error-exit(){
    local msg="$1"
    local status="$2"
    gcreds-error "$msg"
    exit $status
}

function gcreds-env-info(){
    local msg_header=$1
    local dep=$2

    if [[ $dep == "aws" ]]; then
        version_info=$(aws --version 2>&1)
        gcreds-logger "[$msg_header]: awscli version detected: $(echo $version_info | awk '{print $1}')"
        gcreds-logger "[$msg_header]: Python version detected: $(echo $version_info | awk '{print $2}')"
        gcreds-logger "[$msg_header]: Kernel detected: $(echo $version_info | awk '{print $3}')"
        gcreds-logger "[$msg_header]: awscli library detected: $(echo $version_info | awk '{print $4}')"
    elif [[ $dep == "jq" ]]; then
        version_info=$(jq --version 2>&1)
        gcreds-logger "[$msg_header]: json parser detected: $(echo $version_info)"
    else
        gcreds-logger "[$msg_header]: detected: $($prog --version | head -1)"
    fi
    #
    #<-- end function gcreds-env-info -->
    #
}

function gcreds-depcheck(){
    ## test default shell ##
    if [ ! -n "$BASH" ]; then
        # shell other than bash
        gcreds-error-exit "Default shell appears to be something other than bash. Please rerun with bash. Aborting (code $E_BADSHELL)" $E_BADSHELL
    fi

    ## create log dir for gcreds ##
    if [[ ! -d $pkg_path/logs ]]; then
        if ! mkdir -p "$pkg_path/logs"; then
            gcreds-error-exit "$pkg: failed to make log directory: $pkg_path/logs" $E_NOLOG
        fi
    fi

    ## check for required cli tools ##
    for prog in aws jq hostname awk grep cat; do
        if ! type "$prog" > /dev/null 2>&1; then
            gcreds-error-exit "$prog is required and not found in the PATH. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
        if [ $debugMode ]; then
            gcreds-env-info "DBUG" $prog
        fi
    done

    ## check if awscli tools are configured ##
    if [[ ! -f $HOME/.aws/config ]]; then
        gcreds-error-exit "awscli not configured, run 'aws configure'. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
    fi

    ## check for jq, use system installed version if found, otherwise use bundled ##
    if which jq > /dev/null; then
        jq=$(which jq)
    else
        jq="assets/jq/$system/jq"
        if [[ ! -f $jq ]]; then
            gcreds-error-exit "no viable json parser binary (jq) found, Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
    fi

    ## set fs pointer to writeable temp location ##
    if [ "$(df /run | awk '{print $1, $6}' | grep tmpfs 2>/dev/null)" ]; then
            # in-memory
            TMPDIR="/dev/shm"
            cd $TMPDIR
    else
            TMPDIR="/tmp"
            cd $TMPDIR
    fi
    #
    # <-- end function gcreds-depcheck -->
    #
}

function gcreds-authentication(){
    # validate authenthentication to aws apis before writing to awscli config
    if [ ! $1 ] || [ ! $2 ] || [ ! $3 ]; then
        # authenication failed, most likely invalid mfa token
        gcreds-clean .aua.creds.json
        gcreds-error-exit "Authentication Failure: MFA code incorrect. (code $E_AUTHFAIL)" $E_AUTHFAIL
    fi
    #
    #<-- end function gcreds-authentication -->
    #
}

function gcreds-backup(){
    # backup existing awscli config
    if [[ ! -e ~/.aws/credentials.orig ]]; then
        # no config bkup, create
        cp ~/.aws/credentials ~/.aws/credentials.orig
    fi
    #
    #<-- end functions gcreds-backup -->
    #
}

function gcreds-profile-exists(){
    # validate if profile exists in local awscli config
    if [[ $1 == "" ]] && [[ $1 == $MFA_ARN ]]; then
        gcreds-error "Invalid MFA profile name provided ($MFA_PROFILE) Exiting code $E_BADARG." $E_BADARG
        gcreds-help
    elif [[ $1 == "" ]]; then
        gcreds-warn "Profile name ($profile) not in your local config. (code $E_BADPROFILE)." $E_BADPROFILE
        return 1
    fi
    #
    #<-- end function gcreds-profile-exists -->
    #
}

function gcreds-clean(){
    # delete all files given as parameters
    rm $@
    #
    #<-- end function gcreds-clean -->
    #
}

function gcreds-revert-creds(){
    # deletes temp credentials from local awscli config
    #
    local silent=$1
    #
    # log out start
    gcreds-logger "[INFO]: Attempting to remove temp credentials from local config"
    # header
    echo -e "\n--${white}${BOLD} CLEARING LOCAL CONFIG ${UNBOLD}${reset}--\n" | indent10
    echo -e "All temp credentials from your local config will be discarded." | indent02
    echo -e "Your local awscli config will be returned to previous (clean) state.\n" | indent02
    if [ $silent ]; then
        # clean config, no user input
        CHOICE="y"
    else
        read -p "  ${yellow}Purge existing temporary credentials?${reset} [y]:  " CHOICE
    fi
    if [[ -z "$CHOICE" ]] || [[ "$CHOICE" == "y" ]] || [[ "$CHOICE" == "yes" ]]; then
        # restore clean config from backup
        if [[ -e ~/.aws/credentials.orig ]]; then
            mv ~/.aws/credentials.orig ~/.aws/credentials
            gcreds-message "Your local config has been cleaned." INFO
        else
            # no backup exists, clean
            gcreds-message "Nothing done. Your config appears to be clean already." INFO
        fi
    else
        gcreds-message "Temporary credentials remain in your config. Nothing done." INFO
    fi
    #
    # <-- end function gcreds-revert-creds -->
    #
}

function gcreds-parse-parameters(){
    ## help requested ##
    if [[ ! $@ ]]; then
        # display help
        gcreds-help
    else
        while [ $# -gt 0 ]; do
            case $1 in
                -h | --help | -help)
                    # display help
                    gcreds-help
                    ;;
                -r | --revert | -revert | --Revert)
                    revert=1    # flag indicating direct call to clear config
                    if ! gcreds-preexisting-creds $revert; then
                        gcreds-message "You do not have temporary credentials in your config. Nothing to do." INFO
                    fi
                    exit 0
                    ;;
                *.accounts | *.accts)
                    # list of accts to gen temp creds, one per line
                    ACCTFILE=$pkg_path/$1
                    shift 1
                    ;;
                --profile)
                    # iam user profile used to assume roles
                    if [ $2 ]; then
                        MFA_PROFILE=$2
                        shift 2
                    else
                        gcreds-error-exit "You must provide an IAM profile name. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                --mfa-code | --mfacode | --mfa | --code | -c)
                    # otp code from virtual or hw mfa device. verify 6 digit int
                    if [[ $2 =~ ^[0-9]{6}$ ]]; then
                        MFA_CODE=$2
                        shift 2
                    else
                        gcreds-error-exit "You must enter a valid 6 digit mfa code. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                -t | --timeout)     # optional
                    if [ $2 ]; then
                        TIMEOUT=$2
                        shift 2
                    else
                        gcreds-error-exit "You must provide a timeout value. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                *)
                    # invalid argument
                    gcreds-error-exit "Unrecognized argument [ $1 ] given. Exiting (code $E_BADARG)" $E_BADARG
            esac
        done
    fi
    ## check that min required parameters have been supplied ##
    if [ ! $ACCTFILE ]; then
        gcreds-error "You must provide an account list, exiting (code $E_BADARG)." $E_BADARG
        gcreds-help
    fi
    if [ ! $MFA_PROFILE ]; then
        gcreds-error "You must enter an IAM user used to assume roles. Exiting (code $E_BADARG)" $E_BADARG
        gcreds-help
    fi
    if [ ! $MFA_CODE ]; then
        gcreds-error "You must enter a valid 6 digit mfa code. Exiting (code $E_BADARG)" $E_BADARG
        gcreds-help
    fi

    # set remaining assignments
    MFA_ARN=$(aws configure get $MFA_PROFILE.mfa_serial)
    # verify valid mfa_profile
    gcreds-profile-exists $MFA_ARN

    # set timeout
    if [[ ! $TIMEOUT ]]; then
        TIMEOUT=15         # default temp creds expiration, 15 minutes
    else
        gcreds-validate-parameter $TIMEOUT int "Temp credential lifetime" $STS_MIN $STS_MAX "minutes"
    fi
    #
    # <-- end function gcreds-parse-parameters -->
    #
}

function gcreds-preexisting-creds(){
    # verify existence of previous temp credentials
    if [[ $(grep "gcreds" ~/.aws/credentials) ]]; then
        if [ ! $1 ]; then
            # not a direct call via revert parameter
            line2=1     # flag indicating a 2 line msg
            gcreds-warn "You appear to have active temp credentials already in your local config." WARN $line2
            echo -e "These should be cleared before generating new credentials." | indent10
            # clear active creds by restoring from backup, silent mode
            gcreds-revert-creds -s
        else
            # clear active creds by restoring from backup, interactive mode
            gcreds-revert-creds
        fi
        # restor backup of awscli
        gcreds-backup
    else
        # no preexisting credentials in local config
        return 1
    fi
    #
    #<-- end function gcreds-preexisting-creds -->
    #
}

function gcreds-test(){
    # output for testing purposes only
    echo -e "\nACCTFILE: "$ACCTFILE
    echo -e "MFA_PROFILE: "$MFA_PROFILE
    echo -e "MFA_CODE: "$MFA_CODE
    echo -e "TIMEOUT: $TIMEOUT minutes"
    echo -e "MFA_ARN: $MFA_ARN\n"
    exit 0
}

function gcreds-validate-parameter(){
    local parameter=$1          # parameter value to validate range
    local type=$2               # type of value expected
    local msg_description="$3"  # error msg leading description
    local min_value=$4          # min value in range
    local max_value=$5          # max value in range
    local units="$6"            # units, min_value (minutes, lbs, kg, etc)

    ## validate parameter type, integer or decimal ##
    case $type in
        int)
            # integer required
            if ! [[ $parameter =~ ^[0-9]+$ ]]; then
                # parameter is not integer
                gcreds-error-exit "$msg_description must be an integer. Exiting (code $E_BADARG)" $E_BADARG
            fi
            ;;
        float)
            # floating pt decimal required
            if [[ $parameter =~ ^[0-9]+$ ]]; then
                # parameter is integer
                gcreds-error-exit "$msg_description must be a floating point decimal. Exiting (code $E_BADARG)" $E_BADARG
            fi
            ;;
        *)
            # Unrecognized type
            gcreds-error-exit "Unrecognized argument in gcreds-validate-parameter [ $type ]. \
            Exiting (code $E_BADARG)" $E_BADARG
            ;;
    esac
    ## validate range, if limits given ##
    if [ $4 ] && [ $5 ] && [ $6 ]; then
        if [[ $parameter -lt $min_value ]]; then
            # timeout < sts minimum limit
            gcreds-error-exit "$msg_description must be $min_value $units or more. Exiting (code $E_BADARG)" $E_BADARG
        elif [[ $parameter -gt $max_value ]]; then
            # timeout is > sts maximum
            gcreds-error-exit "$msg_description must be less than $max_value $units. Exiting (code $E_BADARG)" $E_BADARG
        fi
    fi
    #
    #<-- end function gcreds-validate-parameter -->
    #
}

#<-- start MAIN -->

# check deps
gcreds-depcheck

# verify backup of existing awscli config
gcreds-backup

# parse inputs
gcreds-parse-parameters $@

# check for active temp credentials before generating new creds
gcreds-preexisting-creds

# log out
gcreds-logger "[INFO]: Attempting to generate session token for iam profile [gcreds-$MFA_PROFILE]"

# generate temp creds for MFA_PROFILE
aws sts get-session-token \
    --duration-seconds $(($TIMEOUT*60)) \
    --serial-number "$MFA_ARN" \
    --token-code "$MFA_CODE" \
    --output json \
    --profile $MFA_PROFILE 2>/dev/null > .aua.creds.json

# create temp profile
AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId .aua.creds.json)
AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey .aua.creds.json)
AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken .aua.creds.json)

# validate authentication
gcreds-authentication $AWS_ACCESS_KEY $AWS_SECRET_KEY $AWS_SESSION_TOKEN

echo " " > ./.new.profile
echo "[gcreds-$MFA_PROFILE]" >> ./.new.profile
echo "aws_access_key_id = $AWS_ACCESS_KEY" >> ./.new.profile
echo "aws_secret_access_key = $AWS_SECRET_KEY" >> ./.new.profile
echo "aws_security_token = $AWS_SESSION_TOKEN" >> ./.new.profile
cat ./.new.profile >> ~/.aws/credentials

# success, log out
gcreds-logger "[INFO]: Generated temp credentials for iam profile [gcreds-$MFA_PROFILE]"

# create temp credentials for each profile in ACCTFILE
for profile in $(cat $ACCTFILE); do
    # assign arn from local config
    role_arn=$(aws configure get $profile.role_arn)

    if gcreds-profile-exists $role_arn; then
        echo -e "\nGenerating temp credentials for profile ${white}${BOLD}$profile${reset}${UNBOLD}" | indent02
        echo -e "Assuming role: ${lgray}$role_arn${reset}\n" | indent02

        # call assume role to gen temp creds
        aws sts assume-role \
            --duration-seconds $(($TIMEOUT*60)) \
            --role-arn "$role_arn" \
            --role-session-name "gcreds-$profile" \
            --output json \
            --profile "gcreds-$MFA_PROFILE" > .creds.json

        # create temp profile
        AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId .creds.json)
        AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey .creds.json)
        AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken .creds.json)

        echo " " > ./.new.profile
        echo "[gcreds-$profile]" >> ./.new.profile
        echo "aws_access_key_id = $AWS_ACCESS_KEY" >> ./.new.profile
        echo "aws_secret_access_key = $AWS_SECRET_KEY" >> ./.new.profile
        echo "aws_security_token = $AWS_SESSION_TOKEN" >> ./.new.profile

        # add to local config
        cat ./.new.profile >> ~/.aws/credentials
        # success, log out
        gcreds-logger "[INFO]: Generated temp credentials for role profile [gcreds-$profile]"
    fi
done

# clean up temp files
gcreds-clean .aua.creds.json .creds.json .new.profile

#<-- end -->

exit 0
