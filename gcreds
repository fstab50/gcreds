#!/bin/bash

# global variables
pkg=$(basename $0)
pkg_path=$(cd $(dirname $0); pwd -P)
gcreds_log="$pkg_path/logs/gcreds.log"
host=$(hostname)
system=$(uname)
debugMode=""    # change this value to "True" to turn on verbose \
                # log output to aid debugging
#
TIMEOUT=900         # temp creds expiration, 15 m

# Formatting
blue=$(tput setaf 4)
cyan=$(tput setaf 6)
green=$(tput setaf 2)
purple=$(tput setaf 5)
red=$(tput setaf 1)
white=$(tput setaf 7)
yellow=$(tput setaf 3)
gray=$(tput setaf 008)
lgray='\033[0;37m'      # light gray
dgray='\033[1;30m'       # dark gray
reset=$(tput sgr0)
#   
BOLD=`tput bold`              
UNBOLD=`tput sgr0` 

# error codes
E_DEPENDENCY=1                # exit code if missing required dependency
E_NOLOG=2                     # exit code if failure to create log dir, log file
E_BADSHELL=3                  # exit code if incorrect shell detected
E_AUTHFAIL=5                  # exit code if authentication failure
E_BADPROFILE=6                # exit code if profile name/ role not found in local config
E_USER_CANCEL=7               # exit code if user cancel
E_BADARG=8                    # exit code if bad input parameter        
E_MISC=11                     # exit code if miscellaneous (unspecified) error

#<-- function declaration -->

function indent02() { sed 's/^/  /'; }

function indent10() { sed 's/^/          /'; }

function gcreds-logger(){
    local msg="$1"
    if [[ ! $gcreds_log ]]; then
        echo "$pkg: failure to call gcreds-logger, $gcreds_log location undefined"
        exit $E_NOLOG
    fi
    echo "$(date +'%b %d %T') $host $pkg: $msg" >> "$gcreds_log"
}

function gcreds-message(){
    local msg="$1"
    gcreds-logger "INFO: $msg"
    [[ $quiet ]] && return
    shift
    pref="----"
    if [[ $1 ]]; then
        pref="${1:0:4}"
        shift
    fi
    echo -e "\n${yellow}[ $cyan$pref$yellow ]$reset  $msg\n"
}

function gcreds-error(){
    local msg="$1"
    gcreds-logger "ERROR: $msg"
    echo -e "\n${yellow}[ ${red}ERRR${yellow} ]$reset  $msg\n"
}

function gcreds-warn(){
    local msg="$1"
    gcreds-logger "WARN: $msg"
    if [ "$3" ]; then
        # there is a second line of the msg, to be printed by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg"
    else
        # msg is only 1 line sent by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg\n"
    fi
}

function gcreds-error-exit(){
    local msg="$1"
    local status="$2"
    gcreds-error "$msg"
    exit $status
}

function gcreds-env-info(){
    local msg_header=$1
    local dep=$2

    if [[ $dep == "aws" ]]; then
        version_info=$(aws --version 2>&1)
        gcreds-logger "[$msg_header]: awscli version detected: $(echo $version_info | awk '{print $1}')"
        gcreds-logger "[$msg_header]: Python version detected: $(echo $version_info | awk '{print $2}')"
        gcreds-logger "[$msg_header]: Kernel detected: $(echo $version_info | awk '{print $3}')"
        gcreds-logger "[$msg_header]: awscli library detected: $(echo $version_info | awk '{print $4}')"
    elif [[ $dep == "jq" ]]; then
        version_info=$(jq --version 2>&1)
        gcreds-logger "[$msg_header]: json parser detected: $(echo $version_info)"
    else
        gcreds-logger "[$msg_header]: detected: $($prog --version | head -1)"
    fi
    #
    #<-- end function gcreds-env-info -->
    #
}

function gcreds-depcheck(){
    ## test default shell ##
    if [ ! -n "$BASH" ]; then
        # shell other than bash 
        gcreds-error-exit "Default shell appears to be something other than bash. Please rerun with bash. Aborting (code $E_BADSHELL)" $E_BADSHELL
    fi 

    ## create log dir for gcreds ##
    if [[ ! -d $pkg_path/logs ]]; then
        if ! mkdir -p "$pkg_path/logs"; then
            gcreds-error-exit "$pkg: failed to make log directory: $pkg_path/logs" $E_NOLOG
        fi
    fi  

    ## check for required cli tools ##
    for prog in aws jq hostname awk grep cat; do
        if ! type "$prog" > /dev/null 2>&1; then
            gcreds-error-exit "$prog is required and not found in the PATH. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
        if [ $debugMode ]; then
            gcreds-env-info "DEBUG" $prog    
        fi
    done

    ## check if awscli tools are configured ##
    if [[ ! -f $HOME/.aws/config ]]; then
        gcreds-error-exit "awscli not configured, run 'aws configure'. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
    fi

    ## check for jq, use system installed version if found, otherwise use bundled ##
    if which jq > /dev/null; then
        jq=$(which jq)
    else
        jq="assets/jq/$system/jq"
        if [[ ! -f $jq ]]; then
            gcreds-error-exit "no viable json parser binary (jq) found, Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
    fi

    ## set fs pointer to writeable temp location ##
    if [ "$(df /run | awk '{print $1, $6}' | grep tmpfs 2>/dev/null)" ]; then
            # in-memory
            TMPDIR="/dev/shm"
            cd $TMPDIR     
    else
            TMPDIR="/tmp"
            cd $TMPDIR 
    fi  

    ## check temp credential lifetime > required min
    if [[ $TIMEOUT -lt 900 ]]; then
        gcreds-error-exit "Requested temporary credential lifetime must be 15 minutes or more. Exiting (code $E_AUTHFAIL)" $E_AUTHFAIL
    fi
    #
    # <-- end function gcreds-depcheck -->
    #
}

function gcreds-authentication(){
    # validate authenthentication to aws apis before writing to awscli config
    if [[ ! $1 ]] || [[ ! $2 ]] || [[ ! $3 ]]; then
        # authenication failed, most likely invalid mfa token
        gcreds-clean .aua.creds.json
        gcreds-error-exit "Authentication Failure: MFA code incorrect. (code $E_AUTHFAIL)" $E_AUTHFAIL
    fi
    #
    #<-- end function gcreds-authentication -->
    #
}

function gcreds-backup(){
    # backup existing awscli config
    if [[ ! -e ~/.aws/credentials.orig ]]; then
        # no config bkup, create 
        cp ~/.aws/credentials ~/.aws/credentials.orig
    fi
    #
    #<-- end functions gcreds-backup -->
    #
}

function gcreds-profile-exists(){
    # validate if profile exists in local awscli config
    if [[ $1 == "" ]] && [[ $1 == $MFA_ARN ]]; then
        gcreds-error "Invalid MFA profile name provided ($MFA_PROFILE) Exiting code $E_BADARG." $E_BADARG
        gcreds-help
    elif [[ $1 == "" ]]; then
        gcreds-warn "Profile name ($profile) not in your local config. (code $E_BADPROFILE)." $E_BADPROFILE
        return 1
    fi
    #
    #<-- end function gcreds-profile-exists -->
    #
}

function gcreds-clean(){
    # delete all files given as parameters
    rm $@
    #
    #<-- end function gcreds-clean -->
    #
}

function gcreds-revert-creds(){
    # deletes temp credentials from local awscli config
    echo -e "\n--${white}${BOLD} CLEARING LOCAL CONFIG ${UNBOLD}${reset}--\n" | indent10
    echo -e "All temp credentials from your local config will be discarded." | indent02
    echo -e "Your local awscli config will be returned to previous (clean) state.\n" | indent02
    read -p "  ${yellow}Are you sure you want to proceed?${reset} [n]:  " CHOICE 

    if [[ -z "$CHOICE" ]] || [[ "$CHOICE" == "n" ]]; then
        gcreds-message "Temporary credentials remain in your config. Nothing done." INFO
    elif [[ "$CHOICE" == "y" ]] || [[ "$CHOICE" == "yes" ]]; then
        # ensure backup exists
        if [[ -e ~/.aws/credentials.orig ]]; then
            mv ~/.aws/credentials.orig ~/.aws/credentials
            gcreds-message "Your local config has been cleaned." INFO
        else
            # no backup exists, clean 
            gcreds-message "Nothing done. Your config appears to be clean already." INFO
        fi
    else
        gcreds-message "Nothing done." INFO
    fi
    #
    # <-- end function gcreds-revert-creds -->
    #
}

function gcreds-parse-parameters(){
    ## help requested ##
    if [[ ! $@ ]]; then
        # display help
        gcreds-help
    else   
        case $1 in
            -h | --help | -help)
                # display help
                gcreds-help
                ;;
            -r | --revert | -revert | --Revert)
                revert=1    # flag indicating direct call to clear config
                if ! gcreds-preexisting-creds $revert; then
                    gcreds-message "You do not have temporary credentials in your config. Nothing to do." INFO
                fi
                exit 0
                ;;
        esac
    fi
    ## check number ##
    if [ $# -ne 3 ]; then
        gcreds-error "3 parameters are required, only $# provided (code $E_BADARG)." $E_BADARG
        gcreds-help
    fi
    
    # set assignments
    ACCTFILE=$pkg_path/$1       # profiles to gen temp creds, one per line
    MFA_PROFILE=$2              # iam user profile used to assume roles
    MFA_CODE=$3                 # otp code from virtual or hw mfa device
    MFA_ARN=$(aws configure get $2.mfa_serial)
    
    ## verify valid mfa_profile ##
    gcreds-profile-exists $MFA_ARN
    #
    # <-- end function gcreds-parse-parameters -->
    #
}

function gcreds-help(){
    cat <<EOM
 
 Help Contents
 -------------

    To generate temporary credentials:

    ${white}${BOLD}Usage${UNBOLD}${reset} : $pkg [OPTION] [profiles.list] [MFA_PROFILENAME] [MFA_TOKEN]

    ${white}${BOLD}Options${UNBOLD}${reset} : (not currently implemented)
        -t, --timeout=N :  temp credential expiration in N seconds (900 sec minimum)
        -s, --silent    :  when given, suppresses all stout messages

    ${white}${BOLD}profiles.list${reset}${UNBOLD} (required)
        list of profile names from your local awscli configuration, one per line
        corresponding to IAM role profiles for which you wish to generate
        temporary credentials. Profiles.list must be in gcreds root directory

    ${white}${BOLD}MFA_PROFILENAME${reset}${UNBOLD} (required)
        profile name in your local awscli configuration that contains the
        arn of your mfa_serial used when assuming roles 

    ${white}${BOLD}MFA_TOKEN${reset}${UNBOLD} (required)
        6 digit numerical code from either a hardware or virtual mfa device
        mfa code must correspond to the MFA_PROFILENAME given        

    ---------------------------------------------------------------------------

    To remove temporary credentials:

    ${white}${BOLD}Usage${UNBOLD}${reset} : $pkg [OPTIONS]

        -r, --revert  :  Clears temporary credentials from your local
                         awscli configuration, returning your config to
                         a pre-gcreds state.

EOM
    exit 0
    #
    #<-- end function gcreds-help -->
    #
}

function gcreds-preexisting-creds(){
    # verify existence of previous temp credentials
    if [[ $(grep "gcreds" ~/.aws/credentials) ]]; then
        if [ ! $1 ]; then
            # not a direct call via revert parameter
            line2=1     # flag indicating a 2 line msg
            gcreds-warn "You appear to have active temp credentials already in your local config." WARN $line2
            echo -e "These should be cleared before generating new credentials." | indent10
        fi
        # clear active creds by restoring from backup
        gcreds-revert-creds
        # restor backup of awscli
        gcreds-backup
    else
        # no preexisting credentials in local config
        return 1
    fi
    #
    #<-- end function gcreds-preexisting-creds -->
    #
}

#<-- start MAIN -->

# check deps
gcreds-depcheck

# verify backup of existing awscli config
gcreds-backup

# parse inputs
gcreds-parse-parameters $@

# check for active temp credentials before generating new creds
gcreds-preexisting-creds

# generate temp creds for MFA_PROFILE
aws sts get-session-token \
    --duration-seconds "$TIMEOUT" \
    --serial-number "$MFA_ARN" \
    --token-code "$MFA_CODE" \
    --output json \
    --profile $MFA_PROFILE 2>/dev/null > .aua.creds.json

# create temp profile
AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId .aua.creds.json)
AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey .aua.creds.json)
AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken .aua.creds.json)

# validate authentication
gcreds-authentication $AWS_ACCESS_KEY $AWS_SECRET_KEY $AWS_SESSION_TOKEN

echo " " > ./.new.profile
echo "[gcreds-$MFA_PROFILE]" >> ./.new.profile
echo "aws_access_key_id = $AWS_ACCESS_KEY" >> ./.new.profile
echo "aws_secret_access_key = $AWS_SECRET_KEY" >> ./.new.profile
echo "aws_security_token = $AWS_SESSION_TOKEN" >> ./.new.profile

cat ./.new.profile >> ~/.aws/credentials

# create temp credentials for each profile in ACCTFILE
for profile in $(cat $ACCTFILE); do
    # assign arn from local config
    role_arn=$(aws configure get $profile.role_arn)

    if gcreds-profile-exists $role_arn; then
        echo -e "\nGenerating temp credentials for profile ${white}${BOLD}$profile${reset}${UNBOLD}"
        echo -e "Assuming role: ${lgray}$role_arn${reset}\n"

        # call assume role to gen temp creds
        aws sts assume-role \
            --duration-seconds "$TIMEOUT" \
            --role-arn "$role_arn" \
            --role-session-name "gcreds-$profile" \
            --output json \
            --profile "gcreds-$MFA_PROFILE" > .creds.json

        # create temp profile
        AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId .creds.json)
        AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey .creds.json)
        AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken .creds.json)

        echo " " > ./.new.profile
        echo "[gcreds-$profile]" >> ./.new.profile
        echo "aws_access_key_id = $AWS_ACCESS_KEY" >> ./.new.profile
        echo "aws_secret_access_key = $AWS_SECRET_KEY" >> ./.new.profile
        echo "aws_security_token = $AWS_SESSION_TOKEN" >> ./.new.profile

        # add to local config
        cat ./.new.profile >> ~/.aws/credentials
    fi
done

# clean up temp files
gcreds-clean .aua.creds.json .creds.json .new.profile

#<-- end -->

exit 0