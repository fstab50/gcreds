#!/bin/bash

# global variables
pkg=$(basename $0)
pkg_path=$(cd $(dirname $0); pwd -P)
pwd_path=$(pwd)
config_path="$HOME/.$pkg"
gcreds_conf="gcreds.cfg"
gcreds_log="$pkg_path/logs/gcreds.log"
host=$(hostname)
system=$(uname)
MONITOR=False
DBUGMODE=""           # change this value to "True" to turn on verbose \
                      # log output to aid debugging

# Amazon Sercurity Token Service (STS) globals
STS_MIN=60            # minutes, STS min credential lifetime
STS_MAX=720           # minutes, credential lifetime max limit (12 hours)
TOKEN_DEFAULT=60      # minutes, default STS session token lifetime
CREDENTIAL_DEFAULT=60 # minutes, default lifetime of temp credentials generated

# error codes
E_DEPENDENCY=1        # exit code if missing required dependency
E_DIR=2               # exit code if failure to create log dir, log file
E_BADSHELL=3          # exit code if incorrect shell detected
E_AUTHFAIL=5          # exit code if authentication failure
E_BADPROFILE=6        # exit code if profile name/ role not found in local config
E_USER_CANCEL=7       # exit code if user cancel
E_BADARG=8            # exit code if bad input parameter
E_EXPIRED_CREDS=9     # exit code if temporary credentials no longer valid
E_MISC=11             # exit code if miscellaneous (unspecified) error

# Formatting
blue=$(tput setaf 4)
cyan=$(tput setaf 6)
green=$(tput setaf 2)
purple=$(tput setaf 5)
red=$(tput setaf 1)
white=$(tput setaf 7)
yellow=$(tput setaf 3)
orange='\\033[38;5;95;38;5;214'
gray=$(tput setaf 008)
lgray='\033[0;37m'    # light gray
dgray='\033[1;30m'    # dark gray
reset=$(tput sgr0)
#
BOLD=`tput bold`
UNBOLD=`tput sgr0`

# default color scheme (blue)
accent=$(tput setaf 008)

#
# function declaration start --------------(do not modify this line)-----------
#

# indent
indent02() { sed 's/^/  /'; }
indent04() { sed 's/^/    /'; }
indent10() { sed 's/^/          /'; }

function gcreds_help(){
    cat <<EOM

 Help Contents
 -------------

    To generate temporary credentials:

    ${accent}${BOLD}Usage${UNBOLD}${reset} : $pkg -a <ACCTFILE> --profile <IAM_PROFILE> -c <MFA_CODE>

    ${accent}${BOLD}OPTIONS${UNBOLD}${reset} :
         -a, --accounts : list of accounts, see ACCTFILE
         -p, --profile  : iam user account, see IAM_PROFILE
         -c, --mfa-code : authentication code, see MFA_CODE
        [-A, --auto     : auto refresh credentials]
        [-s, --show     : show credential expiration info]
        [-C, --config   : set $pkg configuration options]
        [-h, --help     : display this help menu]

    ${accent}${BOLD}ACCTFILE${reset}${UNBOLD} (required)
        text file listing of profile names in your local awscli configuration,
        one per line. Profiles correspond to IAM roles in AWS accounts for
        which you wish to generate temporary credentials.

    ${accent}${BOLD}IAM_PROFILE${reset}${UNBOLD} (required)
        profile name of the IAM user in your local awscli configuration that
        contains the ARN of the mfa_serial used to assume roles

    ${accent}${BOLD}MFA_CODE${reset}${UNBOLD} (required)
        6 digit otp integer code from either a hardware or virtual mfa
        device MFA code must correspond to the IAM_PROFILE given

    ${accent}${BOLD}-A | --auto ${reset}<${accent}value${reset}>${UNBOLD} (optional)
        Auto refresh of temporary credentials for specified number of hours.
        If omitted, temporary credentials are generated only once and expire after
        60 min (default timeout).
                                 -----------

        New profiles added to your awscli config prefixed with '${BOLD}gcreds-${UNBOLD}'

    ---------------------------------------------------------------------------

    To remove temporary credentials:

    ${accent}${BOLD}Usage${UNBOLD}${reset} : $pkg -r

        -r, --remove  :  Clears temporary credentials from your local
                         awscli configuration, returning your config to
                         a pre-gcreds state.

EOM
    exit 0
    #
    #<-- end function gcreds_help -->
}

array2json(){
    ## converts associative array to json file output ##
    local -n array_dict=$1      # local assoc array must use -n opt
    local output_file=$2        # location
    local ct                    # counter
    local max_keys              # num keys in array
    #
    echo -e "{" > $output_file
    ct=1
    max_keys=${#array_dict[@]}
    for key in ${!array_dict[@]}; do
        if [ $ct == $max_keys ]; then
            # last key, no comma
            echo "\"${key}\": \"${array_dict[${key}]}\"" | indent04 >> $output_file
        else
            echo "\"${key}\": \"${array_dict[${key}]}\"," | indent04 >> $output_file
        fi
        ct=$(( $ct + 1 ))
    done
    echo -e "}" >> $output_file
    #
    # <-- end function array2json -->
}

function gcreds_logger(){
    local msg="$1"
    if [[ ! $gcreds_log ]]; then
        echo "$pkg: failure to call gcreds_logger, $gcreds_log location undefined"
        exit $E_DIR
    fi
    echo "$(date +'%b %d %T') $host $pkg: $msg" >> "$gcreds_log"
}

function gcreds_message(){
    local msg="$1"
    gcreds_logger "[INFO]: $msg"
    [[ $quiet ]] && return
    shift
    pref="----"
    if [[ $1 ]]; then
        pref="${1:0:4}"
        shift
    fi
    echo -e "\n${yellow}[ $cyan$pref$yellow ]$reset  $msg\n" | indent02
}

function gcreds_error(){
    local msg="$1"
    gcreds_logger "[ERRR]: $msg"
    echo -e "\n${yellow}[ ${red}ERRR${yellow} ]$reset  $msg\n" | indent02
}

function gcreds_warn(){
    local msg="$1"
    gcreds_logger "[WARN]: $msg"
    if [ "$3" ]; then
        # there is a second line of the msg, to be printed by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg" | indent02
    else
        # msg is only 1 line sent by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg\n" | indent02
    fi
}

function gcreds_error_exit(){
    local msg="$1"
    local status="$2"
    gcreds_error "$msg"
    exit $status
}

function gcreds_env_info(){
    local msg_header=$1
    local dep=$2

    if [[ $dep == "aws" ]]; then
        version_info=$(aws --version 2>&1)
        gcreds_logger "[$msg_header]: awscli version detected: $(echo $version_info | awk '{print $1}')"
        gcreds_logger "[$msg_header]: Python version detected: $(echo $version_info | awk '{print $2}')"
        gcreds_logger "[$msg_header]: Kernel detected: $(echo $version_info | awk '{print $3}')"
        gcreds_logger "[$msg_header]: awscli library detected: $(echo $version_info | awk '{print $4}')"
    elif [[ $dep == "jq" ]]; then
        version_info=$(jq --version 2>&1)
        gcreds_logger "[$msg_header]: json parser detected: $(echo $version_info)"
    else
        gcreds_logger "[$msg_header]: detected: $($prog --version | head -1)"
    fi
    #
    #<-- end function gcreds_env_info -->
}

function gcreds_depcheck(){
    ## test default shell ##
    if [ ! -n "$BASH" ]; then
        # shell other than bash
        gcreds_error_exit "Default shell appears to be something other than bash. Please rerun with bash. Aborting (code $E_BADSHELL)" $E_BADSHELL
    fi
    ## create log dir for gcreds ##
    if [[ ! -d $pkg_path/logs ]]; then
        if ! mkdir -p "$pkg_path/logs"; then
            gcreds_error_exit "$pkg: failed to make log directory: $pkg_path/logs" $E_DIR
        fi
    fi
    ## create gcreds config dir ##
    if [[ ! -d $config_path ]]; then
        gcreds_warn "config_path not found, creating config dir $config_path"
        if ! mkdir -p $config_path; then
            gcreds_error_exit "$pkg: failed to create local config file directory: ~/.$pkg" $E_DIR
        fi
    fi
    ## check for required cli tools ##
    for prog in aws jq date hostname awk grep cat; do
        if ! type "$prog" > /dev/null 2>&1; then
            gcreds_error_exit "$prog is required and not found in the PATH. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
        if [ $DBUGMODE ]; then
            gcreds_env_info "DBUG" $prog
        fi
    done
    ## check if awscli tools are configured ##
    if [[ ! -f $HOME/.aws/config ]]; then
        gcreds_error_exit "awscli not configured, run 'aws configure'. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
    fi
    ## check for jq, use system installed version if found, otherwise use bundled ##
    if which jq > /dev/null; then
        jq=$(which jq)
    else
        jq="assets/jq/$system/jq"
        if [[ ! -f $jq ]]; then
            gcreds_error_exit "no viable json parser binary (jq) found, Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
    fi
    ## set temp to writeable location in physical memory ##
    df=$(which df)
    if [ "$($df /run 2>/dev/null | awk '{print $1, $6}' | grep tmpfs 2>/dev/null)" ]; then
            # in-memory
            TMPDIR="/dev/shm"
    else
            TMPDIR="/tmp"
    fi
    ## set parameters based on configuration options ##
    gcreds_source_config
    #if [[ ! -e $config_path/gcreds.cfg ]]; then
        # configuration options not set
    #    msg="$pkg configuration options not currently set. Do you want to set them now? [yes]"
    #    read -p "$msg" CHOICE
    #    gcreds_configure
    #fi

    #
    # <-- end function gcreds_depcheck -->
}

function gcreds_authentication(){
    # validate authenthentication to aws apis before writing to awscli config
    if [ ! $1 ] || [ ! $2 ] || [ ! $3 ]; then
        # authenication failed, most likely invalid mfa token
        gcreds_clean .aua.creds.json
        gcreds_error_exit "Authentication Failure: MFA code incorrect. (code $E_AUTHFAIL)" $E_AUTHFAIL
    fi
    #
    #<-- end function gcreds_authentication -->
}

function gcreds_backup(){
    # backup existing awscli config
    if [[ ! -e ~/.aws/credentials.orig ]]; then
        # no config bkup, create
        cp ~/.aws/credentials ~/.aws/credentials.orig
    fi
    #
    #<-- end functions gcreds_backup -->
}

function gcreds_clean(){
    # delete all files given as parameters
    if [[ $1 = .* ]]; then
        # temp files
        cd $TMPDIR
        rm $@
        cd $pwd_path
    else
        rm $@
    fi
    #
    #<-- end function gcreds_clean -->
}

function gcreds_configure(){
    ## set configuration options ##
    local ct                        # counter
    local valid                     # loop break
    local CHOICE                    # user entry var
    local COLOR                     # user entry var
    local maxct                     # array size counter
    #
    declare -A config_dict          # key, value dictionary
    declare colors                  # color scheme array
    #
    clear
    echo -e "\n"
    gcreds_message "Configure Mode Start: Set $pkg configuration options" INFO
    # set default profile (default  [atos-aua1])
    echo -e "\nEnter the iam username you will generally use to generate temporary" | indent02
    echo -e "credentials. This user is used to assume roles using temporary credentials" | indent02
    echo -e "provided by $pkg." | indent02
    echo -e "\nA new iam user may be used at any time by including the -p / --profile option" | indent02
    echo -e "as a $pkg command line parameter.\n" | indent02
    read -p "  ${yellow}IAM user [atos-aua1]:${reset} " CHOICE
    if [ -z $CHOICE ]; then
        CHOICE="atos-aua1"
    fi
    echo -e "\n"
    gcreds_message "entering [$CHOICE] in your local $pkg configuration" INFO
    # add config dictionary key, value
    config_dict["default_profile"]=$CHOICE

    # set default color scheme (display choices)
    colors=(
        "LTDB: Light text on dark background"
        "DTLB: Dark text on light background"
        "BLUE: Blue Accent Theme (default)"
        "RED:  Red Accent Theme"
        )
    maxct=${#colors[@]}
    echo -e "\nChoose a default color scheme based on your cli environemnt. Choices:\n" | indent02
    ct=0
    valid=0     # loop break
    while [ $ct -lt ${#colors[@]} ]; do
        echo "[$ct]: ${colors[$ct]}" | indent04
        ct=$(( $ct + 1))
    done
    while [ $valid -eq 0 ]; do
        # validate user input
        echo -e "\n"
        read -p "  ${yellow}Select number of color scheme [0]:${reset} " CHOICE

        if [[ -n ${CHOICE//[0-$(( $maxct-1 ))]/} ]]; then
            # invalid user entry
            echo -e "\nYou must enter an integer number between 0 and $(( $maxct-1 ))."
        else
            # valid user entry, exit loop
            valid=1
        fi
    done
    if [ -z $CHOICE ]; then
        # add config dictionary key, value for 0 element
        COLOR=$(echo ${colors[0]} | awk -F ':' '{print $1}')
    else
        # add config dictionary key, value
        COLOR=$(echo ${colors[$CHOICE]} | awk -F ':' '{print $1}')
    fi

    # add config dictionary key, value
    config_dict["default_color"]=$COLOR
    echo -e "\n"
    gcreds_message "entering color scheme [$COLOR] in your local $pkg configuration" INFO

    # write out config file
    array2json config_dict $config_path/$gcreds_conf

    # log
    gcreds_message "Configuration setup for $pkg complete" INFO
    exit 0
    #
    # <-- end function gcreds_configure -->
}

function gcreds_profile_exists(){
    # validate if profile exists in local awscli config
    if [[ $1 == "" ]] && [[ $1 == $MFA_ARN ]]; then
        gcreds_error "Invalid MFA profile name provided ($MFA_PROFILE) Exiting code $E_BADARG." $E_BADARG
        gcreds_help
    elif [[ $1 == "" ]]; then
        gcreds_warn "Profile name ($profile) not in your local config. (code $E_BADPROFILE)." $E_BADPROFILE
        return 1
    fi
    #
    #<-- end function gcreds_profile_exists -->
}

function gcreds_parse_parameters(){
    ## help requested ##
    if [[ ! $@ ]]; then
        # display help
        gcreds_help
    else
        while [ $# -gt 0 ]; do
            case $1 in
                -h | --help | -help)
                    # display help
                    gcreds_help
                    ;;
                -C | --config)
                    # set configuration options
                    gcreds_configure
                    exit 0
                    ;;
                -r | --remove)
                    rm=1    # flag indicating direct call to clear config
                    if ! gcreds_preexisting_creds $rm; then
                        gcreds_message "You do not have temporary credentials in your config. Nothing to do." INFO
                    fi
                    exit 0
                    ;;
                -a | --accounts | *.accounts | *.accts)
                    # list of accts to gen temp creds, one per line
                    # -f, --file, *.accounts, *.accts for backward compatibility
                    if [ $1 == "-a" ] || [ $1 == "--accounts" ]; then
                        ACCTFILE=$2
                        shift 2
                    fi
                    ;;
                -p | --profile)
                    # iam user profile used to assume roles
                    if [ $2 ]; then
                        MFA_PROFILE=$2
                        shift 2
                    else
                        gcreds_error_exit "You must provide an IAM profile name. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                --mfa-code | --mfacode | --mfa | --code | -c)
                    # otp code from virtual or hw mfa device. verify 6 digit int
                    if [[ $2 =~ ^[0-9]{6}$ ]]; then
                        MFA_CODE=$2
                        shift 2
                    else
                        gcreds_error_exit "You must enter a valid 6 digit mfa code. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                -s | --show)
                    # display info on current credentials, if exist
                    gcreds_show_creds
                    shift 1
                    exit 0
                    ;;
                -A | --auto)     # optional
                    if [ $2 ]; then
                        # $2 given in hours
                        TOKEN_LIFE=$2
                        MONITOR=True    # set monitoring bit
                        shift 2
                    else
                        gcreds_error_exit "You must provide a timeout value. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                *)
                    # invalid argument
                    gcreds_error_exit "Unrecognized argument [ $1 ] given. Exiting (code $E_BADARG)" $E_BADARG
            esac
        done
    fi
    ## check that min required parameters have been supplied ##
    if [ ! $ACCTFILE ]; then
        gcreds_error "You must provide an account list, exiting (code $E_BADARG)." $E_BADARG
        gcreds_help
    fi
    if [ ! $MFA_PROFILE ]; then
        gcreds_error "You must enter an IAM user used to assume roles. Exiting (code $E_BADARG)" $E_BADARG
        gcreds_help
    fi
    if [ ! $MFA_CODE ]; then
        gcreds_error "You must enter a valid 6 digit mfa code. Exiting (code $E_BADARG)" $E_BADARG
        gcreds_help
    fi

    # set remaining assignments
    MFA_ARN=$(aws configure get $MFA_PROFILE.mfa_serial)
    # verify valid mfa_profile
    gcreds_profile_exists $MFA_ARN

    # set session token
    if [[ ! $TOKEN_LIFE ]]; then
        TOKEN_LIFE=$TOKEN_DEFAULT  # default token expiration (minutes)
    else
        # validate session token lifetime
        STS_MIN=$(( $STS_MIN/60 ))
        STS_MAX=$(( $STS_MAX/60 ))
        gcreds_validate_parameter $TOKEN_LIFE int "Temp credential lifetime" $STS_MIN $STS_MAX "hours"
        TOKEN_LIFE=$(( $TOKEN_LIFE*60 ))
    fi
    #
    # <-- end function gcreds_parse_parameters -->
}

function gcreds_preexisting_creds(){
    # verify existence of previous temp credentials
    if [[ $(grep "gcreds" ~/.aws/credentials) ]]; then
        if [ ! $1 ]; then
            # not a direct call via revert parameter
            gcreds_message "Temporary credentials found in your local awscli config." INFO
            # clear active creds by restoring from backup, silent mode
            gcreds_remove_creds -s
        else
            # clear active creds by restoring from backup, interactive mode
            gcreds_remove_creds
        fi
        # restor backup of awscli
        gcreds_backup
    else
        # no preexisting credentials in local config
        return 1
    fi
    #
    #<-- end function gcreds_preexisting_creds -->
}

function gcreds_remove_creds(){
    ## deletes temp credentials from local awscli config ##
    #
    local silent=$1
    #
    # log out start
    gcreds_logger "[INFO]: Attempting to remove temp credentials from local config"
    # header
    echo -e "\n--${accent}${BOLD} CLEARING LOCAL CONFIG ${UNBOLD}${reset}--\n" | indent10
    echo -e "All temp credentials from your local config will be discarded." | indent02
    echo -e "Your local awscli config will be returned to previous (clean) state.\n" | indent02
    if [ $silent ]; then
        # clean config, no user input
        CHOICE="y"
    else
        read -p "  ${yellow}Purge existing temporary credentials?${reset} [y]:  " CHOICE
    fi
    if [[ -z "$CHOICE" ]] || [[ "$CHOICE" == "y" ]] || [[ "$CHOICE" == "yes" ]]; then
        # restore clean config from backup
        if [[ -e ~/.aws/credentials.orig ]]; then
            mv ~/.aws/credentials.orig ~/.aws/credentials
            gcreds_message "Your local config has been cleaned." INFO
            # clear existing credential expiration values
            gcreds_update_expiration 0
            # replace backup with new copy
            gcreds_backup
        else
            # no backup exists, clean
            gcreds_message "Nothing done. Your config appears to be clean already." INFO
        fi
    else
        gcreds_message "Temporary credentials remain in your config. Nothing done." INFO
    fi
    #
    # <-- end function gcreds_remove_creds -->
}

function gcreds_show_creds(){
    ## display credentials in local config ##
    local session_life="$1"     # time remaining in session, minutes
    local credential_life       # seconds until temporary credential expire
    local hrs_left              # duration before expiration, hours
    local min_left              # duration before expiration, min
    local expire                # expiration timestamp, epoch seconds
    local expire_datetime       # expiration timestamp, date/time format
    local msg
    #
    if [[ $(grep "gcreds" ~/.aws/credentials) ]]; then
        msg="\n${BOLD}${accent}Temporary Credentials in local awscli config:${reset}${UNBOLD}\n"
        echo -e $msg | indent02
        grep --color=auto "gcreds" ~/.aws/credentials | indent10
        if [[ -e $config_path/credential.expiration ]]; then
            expire=$(cat $config_path/credential.expiration)
            credential_life=$(( $expire - $(date +%s) ))
        else
            credential_life=0
        fi
        if [ $credential_life -le 0 ]; then
            # Credentials have expired
            echo -e "\n    Your credentials have ${red}expired${reset}.\n" | indent02
        else
            # session stats, auto refresh of credentials
            if [ $session_life ]; then
                ## show credential stats ##
                expire_datetime=$(date --date=@$(cat $config_path/credential.expiration))
                min_left=$(( $credential_life/60 ))    # convert timeleft from sec to min
                if [ $session_life -gt $CREDENTIAL_DEFAULT ]; then
                    echo -e "\nCredential refresh in ${BOLD}${accent}$min_left${reset}${UNBOLD} minutes." | indent02
                    echo -e "Refresh Time: $expire_datetime\n" | indent02
                else
                    # creds will not be refreshed, not enough time remaining in session
                    echo -e "\nCredential expiration in ${BOLD}${accent}$min_left${reset}${UNBOLD} minutes." | indent02
                    echo -e "Expiration Time: $expire_datetime\n" | indent02
                fi

                ## show session stats ##
                expire_datetime=$(date --date=@$(cat $config_path/token.expiration))
                #
                if [ $session_life -le 60 ]; then
                    min_left=$(( $session_life ))    # convert timeleft from sec to min
                    echo -e "Session Expiration in ${BOLD}${accent}$min_left${reset}${UNBOLD} minutes." | indent02
                else
                    # session_life > 1 hr
                    secs_left=$(( $session_life*60 ))    # convert timeleft
                    hrs_left=$(printf '%d\n' $(($secs_left/3600)))
                    min_left=$(printf '%d\n' $(($secs_left%3600/60)))
                    echo -e "Session Expiration in ${BOLD}${accent}$hrs_left${reset}${UNBOLD} hours ${BOLD}${accent}$min_left${reset}${UNBOLD} minutes." | indent02
                fi
                echo -e "Expiration Time: $expire_datetime\n" | indent02
                echo -e "         ----" | indent10
                echo -e "\n${BOLD}$pkg${UNBOLD} Auto-refesh mode." | indent10
                echo -e "   ctrl+c to quit before session end\n" | indent02
            else
                # no extended session, show temp credential stats only
                expire_datetime=$(date --date=@$(cat $config_path/credential.expiration))
                min_left=$(( $credential_life/60 ))    # convert timeleft from sec to min
                echo -e "\nCredential Expiration in ${BOLD}${accent}$min_left${reset}${UNBOLD} minutes." | indent02
                echo -e "Expiration Time: $expire_datetime\n" | indent02
            fi
        fi
    else
        # no existing credentials
        gcreds_message "Your local configuration does not contain credentials." INFO
    fi
    #
    # <-- end function gcreds_show_creds -->
}

function gcreds_source_config(){
    ## source local $pkg configuration options ##
    local choice
    local log_msg
    #
    if [[ -e $config_path/$gcreds_conf ]]; then

        MFA_PROFILE=$(cat $config_path/$gcreds_conf | jq -r .default_profile)
        COLOR_SCHEME=$(cat $config_path/$gcreds_conf | jq -r .default_color)

        # validate config values
        if [ $MFA_PROFILE == null ] || [ $COLOR_SCHEME == null ]; then
            gcreds_warn "Problem reading $pkg config parameters."
            read -p "${yellow}  Do you want to configure $pkg? [yes]:${reset} " choice
            if [ $choice == 'yes' ]; then
                gcreds_configure
            else
                return 0
            fi
        fi

        # set color scheme
        case $COLOR_SCHEME in
            LTDB)
                accent=$(tput setaf 7)      # white
                log_msg="LTDB"
                ;;
            DTLB)
                accent=$(tput setaf 008)    # gray
                log_msg="DTLB"
                ;;
            BLUE)
                accent=$(tput setaf 4)      # blue
                log_msg="BLUE"
                ;;
            RED)
                accent=$(tput setaf 1)      # cyan
                log_msg="RED"
        esac
        # log
        gcreds_logger "[INFO]: gcreds_source_config: MFA_PROFILE = $MFA_PROFILE"
        gcreds_logger "[INFO]: gcreds_source_config: COLOR_SCHEME = $log_msg"
    fi
    #
    # <-- end function gcreds_source_config -->
}

function gcreds_test(){
    ## output for testing purposes only ##
    echo -e "\nACCTFILE: "$ACCTFILE
    echo -e "MFA_PROFILE: "$MFA_PROFILE
    echo -e "MFA_CODE: "$MFA_CODE
    echo -e "TOKEN_LIFE: $TOKEN_LIFE minutes"
    echo -e "MFA_ARN: $MFA_ARN\n"
    exit 0
    #
    # <-- end function greds_test
}

function gcreds_update_expiration(){
    # timestamps for tracking credential expiration
    # state Legend:
    #       0 = clear credential expiration
    #       1 = new credential expiration
    #       2 = expire expiration, but keep config files (not used)
    local state=$1
    #
    if [[ $1 == 0 ]]; then
        rm $config_path/credential.*
        gcreds_logger "[INFO]: Credential expiration values cleared"
    elif [[ $1 == 1 ]]; then
        echo $(date +%s) > $config_path/credential.start
        EXPIRE=$(( $(($CREDENTIAL_DEFAULT*60)) + $(date +%s) ))
        echo $EXPIRE > $config_path/credential.expiration
        gcreds_logger "[INFO]: Created new credential expiration values in $config_path"
    fi
    #
    # <-- end function gcreds_update_expiration -->
}

function gcreds_validate_parameter(){
    ## validate parameter type, integer or decimal ##
    #
    local parameter=$1          # parameter value to validate range
    local type=$2               # type of value expected
    local msg_description="$3"  # error msg leading description
    local min_value=$4          # min value in range
    local max_value=$5          # max value in range
    local units="$6"            # units, min_value (minutes, lbs, kg, etc)
    #
    case $type in
        int)
            # integer required
            if ! [[ $parameter =~ ^[0-9]+$ ]]; then
                # parameter is not integer
                gcreds_error_exit "$msg_description must be an integer. Exiting (code $E_BADARG)" $E_BADARG
            fi
            ;;
        float)
            # floating pt decimal required
            if [[ $parameter =~ ^[0-9]+$ ]]; then
                # parameter is integer
                gcreds_error_exit "$msg_description must be a floating point decimal. Exiting (code $E_BADARG)" $E_BADARG
            fi
            ;;
        *)
            # Unrecognized type
            gcreds_error_exit "Unrecognized argument in gcreds_validate_parameter [ $type ]. \
            Exiting (code $E_BADARG)" $E_BADARG
            ;;
    esac
    ## validate range, if limits given ##
    if [ $4 ] && [ $5 ] && [ $6 ]; then
        if [[ $parameter -lt $min_value ]]; then
            # timeout < sts minimum limit
            gcreds_error_exit "$msg_description must be $min_value $units or more. Exiting (code $E_BADARG)" $E_BADARG
        elif [[ $parameter -gt $max_value ]]; then
            # timeout is > sts maximum
            gcreds_error_exit "$msg_description must be less than $max_value $units. Exiting (code $E_BADARG)" $E_BADARG
        fi
    fi
    #
    #<-- end function gcreds_validate_parameter -->
}

function gcreds_generate_token() {
    ## get session token using primary IAM user (MFA_PROFILE) ##
    gcreds_logger "[INFO]: Generate session token for iam profile [gcreds-$MFA_PROFILE]"
    #
    # generate temp creds for MFA_PROFILE
    aws sts get-session-token \
        --duration-seconds $(($TOKEN_LIFE*60)) \
        --serial-number "$MFA_ARN" \
        --token-code "$MFA_CODE" \
        --output json \
        --profile $MFA_PROFILE 2>/dev/null > $TMPDIR/.aua.creds.json

    # create temp profile
    AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId $TMPDIR/.aua.creds.json)
    AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey $TMPDIR/.aua.creds.json)
    AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken $TMPDIR/.aua.creds.json)

    # validate authentication
    gcreds_authentication $AWS_ACCESS_KEY $AWS_SECRET_KEY $AWS_SESSION_TOKEN

    echo " " > $TMPDIR/.session.profile
    echo "[gcreds-$MFA_PROFILE]" >> $TMPDIR/.session.profile
    echo "aws_access_key_id = $AWS_ACCESS_KEY" >> $TMPDIR/.session.profile
    echo "aws_secret_access_key = $AWS_SECRET_KEY" >> $TMPDIR/.session.profile
    echo "aws_security_token = $AWS_SESSION_TOKEN" >> $TMPDIR/.session.profile
    cat $TMPDIR/.session.profile >> ~/.aws/credentials

    # record token lifetime start, end
    TOKEN_START=$(date +%s)     # epoch seconds
    echo $TOKEN_START > $config_path/token.start
    EXPIRE=$(( $(($TOKEN_LIFE*60)) + $TOKEN_START ))
    echo $EXPIRE > $config_path/token.expiration

    # store on disk for reuse if --auto parameter
    mv -f $TMPDIR/.session.profile $config_path/
    # clean up
    gcreds_clean .aua.creds.json
    #
    # <-- end function gcreds_generate_token -->
}

function gcreds_generate_creds(){
    ## generate actual credentials ##
    gcreds_logger "[INFO]: Generated temp credentials for iam profile [gcreds-$MFA_PROFILE]"
    #
    # create temp credentials for each profile in ACCTFILE
    for profile in $(cat $ACCTFILE); do
        # assign arn from local config
        role_arn=$(aws configure get $profile.role_arn)

        if gcreds_profile_exists $role_arn; then
            echo -e "\nGenerating temp credentials for profile ${accent}${BOLD}$profile${reset}${UNBOLD}" | indent02
            echo -e "Assuming role: ${lgray}$role_arn${reset}\n" | indent02

            # call assume role to gen temp creds
            aws sts assume-role \
                --duration-seconds $(($CREDENTIAL_DEFAULT*60)) \
                --role-arn "$role_arn" \
                --role-session-name "gcreds-$profile" \
                --output json \
                --profile "gcreds-$MFA_PROFILE" > $TMPDIR/.creds.json

            # create temp profile
            AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId $TMPDIR/.creds.json)
            AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey $TMPDIR/.creds.json)
            AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken $TMPDIR/.creds.json)

            echo " " > $TMPDIR/.new.profile
            echo "[gcreds-$profile]" >> $TMPDIR/.new.profile
            echo "aws_access_key_id = $AWS_ACCESS_KEY" >> $TMPDIR/.new.profile
            echo "aws_secret_access_key = $AWS_SECRET_KEY" >> $TMPDIR/.new.profile
            echo "aws_security_token = $AWS_SESSION_TOKEN" >> $TMPDIR/.new.profile

            # add to local config
            cat $TMPDIR/.new.profile >> ~/.aws/credentials
            # success, log out
            gcreds_logger "[INFO]: Generated temp credentials for role profile [gcreds-$profile]"
        fi
    done
    # update credential start, expiration value markers
    gcreds_update_expiration 1
    # log info about aws version used to generate creds
    gcreds_env_info "INFO" aws
    # clean up temp files
    gcreds_clean .creds.json .new.profile
    #
    # <-- end function gcreds_generate_creds -->
}

gcreds_monitor(){
    ## display session & credential lifetime remaining ##
    local delay=5               # screen refresh delay, seconds
    local expire                # expiration timestamp, epoch seconds
    local session_remaining     # time remaining in session, seconds
    #
    sleep $delay
    # clear screen
    clear_bin=$(which clear)
    $clear_bin

    # session time stats
    expire=$(cat $config_path/token.expiration)
    sec_left=$(( $expire - $(date +%s) ))
    SESSION_REMAINING=$(( $sec_left/60 ))   # session duration, minutes

    # credentials time stats
    expire=$(cat $config_path/credential.expiration)
    sec_left=$(( $expire - $(date +%s) ))
    CREDENTIAL_REMAINING=$(( $sec_left/60 ))

    # display
    gcreds_show_creds  $SESSION_REMAINING
    #
    # <-- end function gcreds-show-stats -->
}

#
#<-- start MAIN ----------------------(do not modify this line)----------------
#

# check deps
gcreds_depcheck

# verify backup of existing awscli config
gcreds_backup

# parse inputs
gcreds_parse_parameters $@

# check for active temp credentials before generating new creds
gcreds_preexisting_creds

# generate session token
gcreds_generate_token

# generate temporary credentials
gcreds_generate_creds

if [ $MONITOR == False ]; then
    gcreds_show_creds
else
    while [ $MONITOR == True ]; do
        #
        # calc and display stats
        gcreds_monitor
        #
        if [ $CREDENTIAL_REMAINING -lt 1 ] && [ $SESSION_REMAINING -gt $CREDENTIAL_DEFAULT ]; then
            #
            # clear out expiring creds
            gcreds_remove_creds -s
            # reset session credentials
            cat $config_path/.session.profile >> ~/.aws/credentials
            # generate credentials
            gcreds_generate_creds
            #
        elif [ $CREDENTIAL_REMAINING -lt 1 ] && [ $SESSION_REMAINING -le $CREDENTIAL_DEFAULT ]; then
            gcreds_message "[INFO]: session end" INFO
            MONITOR=False
        fi
    done
fi

# clean out token, .session.profile from config_path (credential.expiration persist)
rm $config_path/.session.profile $config_path/token.*

#
#<-- end MAIN -----------------------------------------------------------------
#
exit 0
