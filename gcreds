#!/bin/bash

# global variables
pkg=$(basename $0)
pkg_path=$(cd $(dirname $0); pwd -P)
config_path="$HOME/.$pkg"
gcreds_log="$pkg_path/logs/gcreds.log"
host=$(hostname)
system=$(uname)
debugMode=""    # change this value to "True" to turn on verbose \
                # log output to aid debugging

# Amazon Sercurity Token Service (STS) limits
STS_MIN=15      # minutes, equivalent to 900 seconds
STS_MAX=2160    # minutes, equivalent to 36 hours

# error codes
E_DEPENDENCY=1                # exit code if missing required dependency
E_DIR=2                     # exit code if failure to create log dir, log file
E_BADSHELL=3                  # exit code if incorrect shell detected
E_AUTHFAIL=5                  # exit code if authentication failure
E_BADPROFILE=6                # exit code if profile name/ role not found in local config
E_USER_CANCEL=7               # exit code if user cancel
E_BADARG=8                    # exit code if bad input parameter
E_MISC=11                     # exit code if miscellaneous (unspecified) error

# Formatting
blue=$(tput setaf 4)
cyan=$(tput setaf 6)
green=$(tput setaf 2)
purple=$(tput setaf 5)
red=$(tput setaf 1)
white=$(tput setaf 7)
yellow=$(tput setaf 3)
gray=$(tput setaf 008)
lgray='\033[0;37m'      # light gray
dgray='\033[1;30m'       # dark gray
reset=$(tput sgr0)
#
BOLD=`tput bold`
UNBOLD=`tput sgr0`

#<-- function declaration -->

# indent
indent02() { sed 's/^/  /'; }
indent10() { sed 's/^/          /'; }

function gcreds_help(){
    cat <<EOM

 Help Contents
 -------------

    To generate temporary credentials:

    ${white}${BOLD}Usage${UNBOLD}${reset} : $pkg [OPTIONS] <*.accounts> --profile <IAM_PROFILE> -c <MFA_CODE>

    ${white}${BOLD}OPTIONS${UNBOLD}${reset} :
        -t, --timeout  : temp credential expiration in minutes (15 minute default)
        -c, --mfa-code : required, see IAM_PROFILE
        -s, --show     : display info about temp credentials in local config

    <${white}${BOLD}*.accounts${reset}${UNBOLD}> (required)
        text file listing of profile names in your local awscli configuration, one
        per line corresponding to IAM roles and accounts for which you wish to
        generate temporary credentials. File must be located in gcreds root directory

    ${white}${BOLD}IAM_PROFILE${reset}${UNBOLD} (required)
        profile name of the IAM user in your local awscli configuration that
        contains the ARN of your mfa_serial used to assume roles

    ${white}${BOLD}MFA_CODE${reset}${UNBOLD} (required)
        6 digit otp code from either a hardware or virtual mfa device
        MFA code must correspond to the IAM_PROFILE given

                                 -----------

        New profiles added to your awscli config prefixed with '${BOLD}gcreds-${UNBOLD}'

    ---------------------------------------------------------------------------

    To remove temporary credentials:

    ${white}${BOLD}Usage${UNBOLD}${reset} : $pkg [OPTIONS]

        -r, --revert  :  Clears temporary credentials from your local
                         awscli configuration, returning your config to
                         a pre-gcreds state.

EOM
    exit 0
    #
    #<-- end function gcreds_help -->
    #
}

function gcreds_logger(){
    local msg="$1"
    if [[ ! $gcreds_log ]]; then
        echo "$pkg: failure to call gcreds_logger, $gcreds_log location undefined"
        exit $E_DIR
    fi
    echo "$(date +'%b %d %T') $host $pkg: $msg" >> "$gcreds_log"
}

function gcreds_message(){
    local msg="$1"
    gcreds_logger "[INFO]: $msg"
    [[ $quiet ]] && return
    shift
    pref="----"
    if [[ $1 ]]; then
        pref="${1:0:4}"
        shift
    fi
    echo -e "\n${yellow}[ $cyan$pref$yellow ]$reset  $msg\n" | indent02
}

function gcreds_error(){
    local msg="$1"
    gcreds_logger "[ERRR]: $msg"
    echo -e "\n${yellow}[ ${red}ERRR${yellow} ]$reset  $msg\n" | indent02
}

function gcreds_warn(){
    local msg="$1"
    gcreds_logger "[WARN]: $msg"
    if [ "$3" ]; then
        # there is a second line of the msg, to be printed by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg" | indent02
    else
        # msg is only 1 line sent by the caller
        echo -e "\n${yellow}[ ${red}WARN${yellow} ]$reset  $msg\n" | indent02
    fi
}

function gcreds_error_exit(){
    local msg="$1"
    local status="$2"
    gcreds_error "$msg"
    exit $status
}

function gcreds_env_info(){
    local msg_header=$1
    local dep=$2

    if [[ $dep == "aws" ]]; then
        version_info=$(aws --version 2>&1)
        gcreds_logger "[$msg_header]: awscli version detected: $(echo $version_info | awk '{print $1}')"
        gcreds_logger "[$msg_header]: Python version detected: $(echo $version_info | awk '{print $2}')"
        gcreds_logger "[$msg_header]: Kernel detected: $(echo $version_info | awk '{print $3}')"
        gcreds_logger "[$msg_header]: awscli library detected: $(echo $version_info | awk '{print $4}')"
    elif [[ $dep == "jq" ]]; then
        version_info=$(jq --version 2>&1)
        gcreds_logger "[$msg_header]: json parser detected: $(echo $version_info)"
    else
        gcreds_logger "[$msg_header]: detected: $($prog --version | head -1)"
    fi
    #
    #<-- end function gcreds_env_info -->
    #
}

function gcreds_depcheck(){
    ## test default shell ##
    if [ ! -n "$BASH" ]; then
        # shell other than bash
        gcreds_error_exit "Default shell appears to be something other than bash. Please rerun with bash. Aborting (code $E_BADSHELL)" $E_BADSHELL
    fi
    ## create log dir for gcreds ##
    if [[ ! -d $pkg_path/logs ]]; then
        if ! mkdir -p "$pkg_path/logs"; then
            gcreds_error_exit "$pkg: failed to make log directory: $pkg_path/logs" $E_DIR
        fi
    fi
    ## create gcreds config dir ##
    if [[ ! -d $config_path ]]; then
        echo "config_path NOT FOUND"
        if ! mkdir -p $config_path; then
            gcreds_error_exit "$pkg: failed to create local config file directory: ~/.$pkg" $E_DIR
        fi
    fi
    ## check for required cli tools ##
    for prog in aws jq hostname awk grep cat; do
        if ! type "$prog" > /dev/null 2>&1; then
            gcreds_error_exit "$prog is required and not found in the PATH. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
        if [ $debugMode ]; then
            gcreds_env_info "DBUG" $prog
        fi
    done
    ## check if awscli tools are configured ##
    if [[ ! -f $HOME/.aws/config ]]; then
        gcreds_error_exit "awscli not configured, run 'aws configure'. Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
    fi
    ## check for jq, use system installed version if found, otherwise use bundled ##
    if which jq > /dev/null; then
        jq=$(which jq)
    else
        jq="assets/jq/$system/jq"
        if [[ ! -f $jq ]]; then
            gcreds_error_exit "no viable json parser binary (jq) found, Aborting (code $E_DEPENDENCY)" $E_DEPENDENCY
        fi
    fi
    ## set fs pointer to writeable temp location ##
    if [ "$(df /run | awk '{print $1, $6}' | grep tmpfs 2>/dev/null)" ]; then
            # in-memory
            TMPDIR="/dev/shm"
            cd $TMPDIR
    else
            TMPDIR="/tmp"
            cd $TMPDIR
    fi
    #
    # <-- end function gcreds_depcheck -->
    #
}

function gcreds_authentication(){
    # validate authenthentication to aws apis before writing to awscli config
    if [ ! $1 ] || [ ! $2 ] || [ ! $3 ]; then
        # authenication failed, most likely invalid mfa token
        gcreds_clean .aua.creds.json
        gcreds_error_exit "Authentication Failure: MFA code incorrect. (code $E_AUTHFAIL)" $E_AUTHFAIL
    fi
    #
    #<-- end function gcreds_authentication -->
    #
}

function gcreds_backup(){
    # backup existing awscli config
    if [[ ! -e ~/.aws/credentials.orig ]]; then
        # no config bkup, create
        cp ~/.aws/credentials ~/.aws/credentials.orig
    fi
    #
    #<-- end functions gcreds_backup -->
    #
}

function gcreds_clean(){
    # delete all files given as parameters
    rm $@
    #
    #<-- end function gcreds_clean -->
    #
}

function gcreds_profile_exists(){
    # validate if profile exists in local awscli config
    if [[ $1 == "" ]] && [[ $1 == $MFA_ARN ]]; then
        gcreds_error "Invalid MFA profile name provided ($MFA_PROFILE) Exiting code $E_BADARG." $E_BADARG
        gcreds_help
    elif [[ $1 == "" ]]; then
        gcreds_warn "Profile name ($profile) not in your local config. (code $E_BADPROFILE)." $E_BADPROFILE
        return 1
    fi
    #
    #<-- end function gcreds_profile_exists -->
    #
}

function gcreds_revert_creds(){
    # deletes temp credentials from local awscli config
    #
    local silent=$1
    #
    # log out start
    gcreds_logger "[INFO]: Attempting to remove temp credentials from local config"
    # header
    echo -e "\n--${white}${BOLD} CLEARING LOCAL CONFIG ${UNBOLD}${reset}--\n" | indent10
    echo -e "All temp credentials from your local config will be discarded." | indent02
    echo -e "Your local awscli config will be returned to previous (clean) state.\n" | indent02
    if [ $silent ]; then
        # clean config, no user input
        CHOICE="y"
    else
        read -p "  ${yellow}Purge existing temporary credentials?${reset} [y]:  " CHOICE
    fi
    if [[ -z "$CHOICE" ]] || [[ "$CHOICE" == "y" ]] || [[ "$CHOICE" == "yes" ]]; then
        # restore clean config from backup
        if [[ -e ~/.aws/credentials.orig ]]; then
            mv ~/.aws/credentials.orig ~/.aws/credentials
            gcreds_message "Your local config has been cleaned." INFO
        else
            # no backup exists, clean
            gcreds_message "Nothing done. Your config appears to be clean already." INFO
        fi
    else
        gcreds_message "Temporary credentials remain in your config. Nothing done." INFO
    fi
    #
    # <-- end function gcreds_revert_creds -->
    #
}

function gcreds_parse_parameters(){
    ## help requested ##
    if [[ ! $@ ]]; then
        # display help
        gcreds_help
    else
        while [ $# -gt 0 ]; do
            case $1 in
                -h | --help | -help)
                    # display help
                    gcreds_help
                    ;;
                -r | --revert | -revert | --Revert)
                    revert=1    # flag indicating direct call to clear config
                    if ! gcreds_preexisting_creds $revert; then
                        gcreds_message "You do not have temporary credentials in your config. Nothing to do." INFO
                    fi
                    exit 0
                    ;;
                *.accounts | *.accts)
                    # list of accts to gen temp creds, one per line
                    ACCTFILE=$pkg_path/$1
                    shift 1
                    ;;
                --profile)
                    # iam user profile used to assume roles
                    if [ $2 ]; then
                        MFA_PROFILE=$2
                        shift 2
                    else
                        gcreds_error_exit "You must provide an IAM profile name. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                --mfa-code | --mfacode | --mfa | --code | -c)
                    # otp code from virtual or hw mfa device. verify 6 digit int
                    if [[ $2 =~ ^[0-9]{6}$ ]]; then
                        MFA_CODE=$2
                        shift 2
                    else
                        gcreds_error_exit "You must enter a valid 6 digit mfa code. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                -s | --show)
                    # display info on current credentials, if exist
                    gcreds_show_creds
                    shift 1
                    exit 0
                    ;;
                -t | --timeout)     # optional
                    if [ $2 ]; then
                        TIMEOUT=$2
                        shift 2
                    else
                        gcreds_error_exit "You must provide a timeout value. Exiting (code $E_BADARG)" $E_BADARG
                    fi
                    ;;
                *)
                    # invalid argument
                    gcreds_error_exit "Unrecognized argument [ $1 ] given. Exiting (code $E_BADARG)" $E_BADARG
            esac
        done
    fi
    ## check that min required parameters have been supplied ##
    if [ ! $ACCTFILE ]; then
        gcreds_error "You must provide an account list, exiting (code $E_BADARG)." $E_BADARG
        gcreds_help
    fi
    if [ ! $MFA_PROFILE ]; then
        gcreds_error "You must enter an IAM user used to assume roles. Exiting (code $E_BADARG)" $E_BADARG
        gcreds_help
    fi
    if [ ! $MFA_CODE ]; then
        gcreds_error "You must enter a valid 6 digit mfa code. Exiting (code $E_BADARG)" $E_BADARG
        gcreds_help
    fi

    # set remaining assignments
    MFA_ARN=$(aws configure get $MFA_PROFILE.mfa_serial)
    # verify valid mfa_profile
    gcreds_profile_exists $MFA_ARN

    # set timeout
    if [[ ! $TIMEOUT ]]; then
        TIMEOUT=15         # default temp creds expiration, 15 minutes
    else
        gcreds_validate_parameter $TIMEOUT int "Temp credential lifetime" $STS_MIN $STS_MAX "minutes"
    fi
    #
    # <-- end function gcreds_parse_parameters -->
    #
}

function gcreds_preexisting_creds(){
    # verify existence of previous temp credentials
    if [[ $(grep "gcreds" ~/.aws/credentials) ]]; then
        if [ ! $1 ]; then
            # not a direct call via revert parameter
            line2=1     # flag indicating a 2 line msg
            gcreds_warn "You appear to have active temp credentials already in your local config." WARN $line2
            echo -e "These should be cleared before generating new credentials." | indent10
            # clear active creds by restoring from backup, silent mode
            gcreds_revert_creds -s
        else
            # clear active creds by restoring from backup, interactive mode
            gcreds_revert_creds
        fi
        # restor backup of awscli
        gcreds_backup
    else
        # no preexisting credentials in local config
        return 1
    fi
    #
    #<-- end function gcreds_preexisting_creds -->
    #
}

function gcreds_show_creds(){
    # display credentials in local config
    local msg
    if [[ $(grep "gcreds" ~/.aws/credentials) ]]; then
        msg="\n${BOLD}${white}Credentials contained in local config:${reset}${UNBOLD}\n"
        echo -e $msg | indent02
        grep --color=auto "gcreds" ~/.aws/credentials | indent10
        EXPIRE=$(cat $config_path/credential.expiration)
        TIMELEFT=$(( $EXPIRE - $(date +%s) ))
        if [ $TIMELEFT -lt 0 ]; then
            # Credentials have expired
            echo -e "\n    Your credentials have expired.\n" | indent02
        else
            TIMEEXPIRE=$(date --date=@$(( $TIMELEFT + $(date +%s) )))
            TIMELEFT=$(( $TIMELEFT/60 ))    # convert timeleft from sec to min
            echo -e "\nCredential Expiration in ${BOLD}${white}$TIMELEFT${reset}${UNBOLD} minutes." | indent02
            echo -e "Expiration: $TIMEEXPIRE\n" | indent02
        fi
    else
        # no existing credentials
        gcreds_message "Your local configuration does not contain credentials." INFO
    fi
    # <-- end function gcreds_show_creds -->
}

function gcreds_test(){
    # output for testing purposes only
    echo -e "\nACCTFILE: "$ACCTFILE
    echo -e "MFA_PROFILE: "$MFA_PROFILE
    echo -e "MFA_CODE: "$MFA_CODE
    echo -e "TIMEOUT: $TIMEOUT minutes"
    echo -e "MFA_ARN: $MFA_ARN\n"
    exit 0
    # <-- end function greds_test
}

function gcreds_update_expiration(){
    # timestamps for tracking credential expiration
    echo $(date +%s) > $config_path/credential.start
    EXPIRE=$(( $(($TIMEOUT*60)) + $(date +%s) ))
    echo $EXPIRE > $config_path/credential.expiration
    # <-- end function gcreds_update_expiration -->
}

function gcreds_validate_parameter(){
    local parameter=$1          # parameter value to validate range
    local type=$2               # type of value expected
    local msg_description="$3"  # error msg leading description
    local min_value=$4          # min value in range
    local max_value=$5          # max value in range
    local units="$6"            # units, min_value (minutes, lbs, kg, etc)

    ## validate parameter type, integer or decimal ##
    case $type in
        int)
            # integer required
            if ! [[ $parameter =~ ^[0-9]+$ ]]; then
                # parameter is not integer
                gcreds_error_exit "$msg_description must be an integer. Exiting (code $E_BADARG)" $E_BADARG
            fi
            ;;
        float)
            # floating pt decimal required
            if [[ $parameter =~ ^[0-9]+$ ]]; then
                # parameter is integer
                gcreds_error_exit "$msg_description must be a floating point decimal. Exiting (code $E_BADARG)" $E_BADARG
            fi
            ;;
        *)
            # Unrecognized type
            gcreds_error_exit "Unrecognized argument in gcreds_validate_parameter [ $type ]. \
            Exiting (code $E_BADARG)" $E_BADARG
            ;;
    esac
    ## validate range, if limits given ##
    if [ $4 ] && [ $5 ] && [ $6 ]; then
        if [[ $parameter -lt $min_value ]]; then
            # timeout < sts minimum limit
            gcreds_error_exit "$msg_description must be $min_value $units or more. Exiting (code $E_BADARG)" $E_BADARG
        elif [[ $parameter -gt $max_value ]]; then
            # timeout is > sts maximum
            gcreds_error_exit "$msg_description must be less than $max_value $units. Exiting (code $E_BADARG)" $E_BADARG
        fi
    fi
    #
    #<-- end function gcreds_validate_parameter -->
}

function gcreds_generate_creds(){
    # generate actual credentials
    # log out, start
    gcreds_logger "[INFO]: Attempting to generate session token for iam profile [gcreds-$MFA_PROFILE]"

    # generate temp creds for MFA_PROFILE
    aws sts get-session-token \
        --duration-seconds $(($TIMEOUT*60)) \
        --serial-number "$MFA_ARN" \
        --token-code "$MFA_CODE" \
        --output json \
        --profile $MFA_PROFILE 2>/dev/null > .aua.creds.json

    # create temp profile
    AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId .aua.creds.json)
    AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey .aua.creds.json)
    AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken .aua.creds.json)

    # validate authentication
    gcreds_authentication $AWS_ACCESS_KEY $AWS_SECRET_KEY $AWS_SESSION_TOKEN

    echo " " > ./.new.profile
    echo "[gcreds-$MFA_PROFILE]" >> ./.new.profile
    echo "aws_access_key_id = $AWS_ACCESS_KEY" >> ./.new.profile
    echo "aws_secret_access_key = $AWS_SECRET_KEY" >> ./.new.profile
    echo "aws_security_token = $AWS_SESSION_TOKEN" >> ./.new.profile
    cat ./.new.profile >> ~/.aws/credentials

    # success, log out
    gcreds_logger "[INFO]: Generated temp credentials for iam profile [gcreds-$MFA_PROFILE]"

    # create temp credentials for each profile in ACCTFILE
    for profile in $(cat $ACCTFILE); do
        # assign arn from local config
        role_arn=$(aws configure get $profile.role_arn)

        if gcreds_profile_exists $role_arn; then
            echo -e "\nGenerating temp credentials for profile ${white}${BOLD}$profile${reset}${UNBOLD}" | indent02
            echo -e "Assuming role: ${lgray}$role_arn${reset}\n" | indent02

            # call assume role to gen temp creds
            aws sts assume-role \
                --duration-seconds $(($TIMEOUT*60)) \
                --role-arn "$role_arn" \
                --role-session-name "gcreds-$profile" \
                --output json \
                --profile "gcreds-$MFA_PROFILE" > .creds.json

            # create temp profile
            AWS_ACCESS_KEY=$(jq -r .Credentials.AccessKeyId .creds.json)
            AWS_SECRET_KEY=$(jq -r .Credentials.SecretAccessKey .creds.json)
            AWS_SESSION_TOKEN=$(jq -r .Credentials.SessionToken .creds.json)

            echo " " > ./.new.profile
            echo "[gcreds-$profile]" >> ./.new.profile
            echo "aws_access_key_id = $AWS_ACCESS_KEY" >> ./.new.profile
            echo "aws_secret_access_key = $AWS_SECRET_KEY" >> ./.new.profile
            echo "aws_security_token = $AWS_SESSION_TOKEN" >> ./.new.profile

            # add to local config
            cat ./.new.profile >> ~/.aws/credentials
            # success, log out
            gcreds_logger "[INFO]: Generated temp credentials for role profile [gcreds-$profile]"
            gcreds_update_expiration
        fi
    done
    # <-- end function gcreds_generate_creds -->
}

#<-- start MAIN -------------------------------------------------------------->

# check deps
gcreds_depcheck

# verify backup of existing awscli config
gcreds_backup

# parse inputs
gcreds_parse_parameters $@

# check for active temp credentials before generating new creds
gcreds_preexisting_creds

# generate credentials
gcreds_generate_creds

# clean up temp files
gcreds_clean .aua.creds.json .creds.json .new.profile

#<-- end MAIN ---------------------------------------------------------------->

exit 0
